{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractProps = extractProps;\nexports.mergeUnderscoreProps = mergeUnderscoreProps;\nexports.calculateProps = calculateProps;\nexports.resolveValueWithBreakpoint = exports.extractPropertyFromFunction = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _lodash = _interopRequireDefault(require(\"lodash.get\"));\n\nvar _lodash2 = _interopRequireDefault(require(\"lodash.isnil\"));\n\nvar _lodash3 = _interopRequireDefault(require(\"lodash.mergewith\"));\n\nvar _lodash4 = _interopRequireDefault(require(\"lodash.clonedeep\"));\n\nvar _base = require(\"./../../theme/base\");\n\nvar _tools = require(\"./../../theme/tools\");\n\nvar _useContrastText = require(\"../useContrastText\");\n\nfunction extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint) {\n  var newProps = {};\n\n  for (var property in props) {\n    if (_base.themePropertyMap[property]) {\n      var propValues = extractPropertyFromFunction(property, props, theme, componentTheme);\n\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!(0, _lodash2.default)(propValues)) {\n        for (var nestedProp in propValues) {\n          newProps[nestedProp] = (0, _lodash.default)(theme, _base.themePropertyMap[nestedProp] + \".\" + propValues[nestedProp], propValues[nestedProp]);\n        }\n      } else if (property === 'shadow') {\n        var shadowProps = theme[_base.themePropertyMap[property]](colorModeProps)[props[property]];\n\n        if (!(0, _lodash2.default)(shadowProps)) {\n          newProps = (0, _extends2.default)({}, newProps, shadowProps);\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(props[property], currentBreakpoint, property);\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(props[property], currentBreakpoint, property);\n    }\n  }\n\n  return (0, _lodash4.default)(newProps);\n}\n\nfunction filterDefaultProps(props, defaultProps) {\n  var _extractInObject = (0, _tools.extractInObject)(defaultProps, Object.keys(props)),\n      _extractInObject2 = (0, _slicedToArray2.default)(_extractInObject, 2),\n      resultProps = _extractInObject2[1];\n\n  return resultProps;\n}\n\nvar extractPropertyFromFunction = function extractPropertyFromFunction(property, props, theme, componentTheme) {\n  var propValues;\n\n  if (componentTheme && typeof componentTheme[_base.themePropertyMap[property]] === 'function') {\n    var funcProps = componentTheme[_base.themePropertyMap[property]]((0, _extends2.default)({\n      theme: theme\n    }, props));\n\n    var isNested = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    });\n    propValues = isNested ? (0, _extends2.default)({}, (0, _lodash.default)(funcProps, \"\" + props[property])) : (0, _extends2.default)({}, funcProps);\n  } else {\n    propValues = (0, _lodash.default)(componentTheme, _base.themePropertyMap[property] + \".\" + props[property]);\n  }\n\n  return propValues;\n};\n\nexports.extractPropertyFromFunction = extractPropertyFromFunction;\n\nfunction mergeUnderscoreProps(newProps, props) {\n  var _props = Object.keys(newProps).filter(function (propName) {\n    return propName.startsWith('_');\n  });\n\n  _props.forEach(function (propName) {\n    var _newProps$bg, _newProps$propName$co, _newProps$propName, _props$propName;\n\n    var bg = (_newProps$bg = newProps.bg) != null ? _newProps$bg : newProps.backgroundColor;\n    var textColor = bg ? {\n      color: (0, _useContrastText.useContrastText)(bg, (_newProps$propName$co = (_newProps$propName = newProps[propName]) == null ? void 0 : _newProps$propName.color) != null ? _newProps$propName$co : (_props$propName = props[propName]) == null ? void 0 : _props$propName.color)\n    } : {};\n    newProps[propName] = (0, _extends2.default)({}, textColor, newProps[propName], props[propName]);\n  });\n\n  return newProps;\n}\n\nvar resolveValueWithBreakpoint = function resolveValueWithBreakpoint(values, currentBreakpoint, property) {\n  if ((0, _tools.hasValidBreakpointFormat)(values, property)) {\n    return (0, _tools.findLastValidBreakpoint)(values, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\n\nexports.resolveValueWithBreakpoint = resolveValueWithBreakpoint;\n\nfunction calculateProps(theme, colorModeProps, componentTheme, props, windowWidth) {\n  var currentBreakpoint = (0, _tools.getClosestBreakpoint)(theme.breakpoints, windowWidth);\n\n  if (!props) {\n    props = {};\n  }\n\n  var newProps;\n\n  if (componentTheme) {\n    newProps = extractProps(filterDefaultProps(props, componentTheme.defaultProps), theme, colorModeProps, componentTheme, currentBreakpoint);\n    var componentBaseStyle = typeof componentTheme.baseStyle !== 'function' ? componentTheme.baseStyle : componentTheme.baseStyle((0, _extends2.default)({\n      theme: theme\n    }, newProps, props, colorModeProps));\n    newProps = (0, _lodash3.default)(newProps, componentBaseStyle, function (objValue, srcValue, key) {\n      if (!(0, _lodash2.default)(objValue)) {\n        delete newProps[key];\n      }\n    });\n    var variant = props.variant || (0, _lodash.default)(componentTheme, 'defaultProps.variant');\n\n    if (variant && componentTheme.variants && componentTheme.variants[variant]) {\n      var colorScheme = props.colorScheme || (0, _lodash.default)(componentTheme, 'defaultProps.colorScheme');\n      var variantProps = componentTheme.variants[variant]((0, _extends2.default)({}, props, newProps, {\n        colorScheme: colorScheme,\n        theme: theme\n      }, colorModeProps));\n      variantProps = extractProps(variantProps, theme, colorModeProps, componentTheme, currentBreakpoint);\n      newProps = (0, _lodash3.default)(newProps, variantProps, function (objValue, srcValue, key) {\n        if (!(0, _lodash2.default)(objValue)) {\n          delete newProps[key];\n        }\n      });\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  }\n\n  var extractedProps = extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint);\n  newProps = (0, _lodash3.default)(newProps, extractedProps, function (objValue, srcValue, key) {\n    if (!(0, _lodash2.default)(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}","map":{"version":3,"sources":["utils.ts"],"names":["newProps","themePropertyMap","propValues","extractPropertyFromFunction","property","shadowProps","theme","props","resolveValueWithBreakpoint","resultProps","Object","componentTheme","funcProps","isNested","_props","propName","bg","textColor","color","currentBreakpoint","extractProps","filterDefaultProps","componentBaseStyle","variant","colorScheme","variantProps","extractedProps","mergeUnderscoreProps"],"mappings":"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","sourcesContent":["import get from 'lodash.get';\nimport isNil from 'lodash.isnil';\nimport mergeWith from 'lodash.mergewith';\nimport cloneDeep from 'lodash.clonedeep';\nimport { themePropertyMap } from './../../theme/base';\nimport {\n  getClosestBreakpoint,\n  findLastValidBreakpoint,\n  hasValidBreakpointFormat,\n  extractInObject,\n} from './../../theme/tools';\nimport { useContrastText } from '../useContrastText';\n\n/*\n Extract props from theme props and omit those from props\n*/\n/**\n *\n * @param props Props passed by the user\n * @param theme Theme object\n * @param colorModeProps `colorMode` object\n * @param componentTheme Theme for specific components\n * @param currentBreakpoint Current breakpoint values\n * @returns Extracting props from defaultProps while overriding the props that are already present\n */\nexport function extractProps(\n  props: any,\n  theme: any,\n  colorModeProps: any,\n  componentTheme: any,\n  currentBreakpoint: number\n) {\n  let newProps: any = {};\n  for (let property in props) {\n    // If the property exists in themePropertyMap then get its value\n    if (themePropertyMap[property]) {\n      let propValues = extractPropertyFromFunction(\n        property,\n        props,\n        theme,\n        componentTheme\n      );\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!isNil(propValues)) {\n        for (let nestedProp in propValues) {\n          newProps[nestedProp] = get(\n            theme,\n            `${themePropertyMap[nestedProp]}.${propValues[nestedProp]}`,\n            propValues[nestedProp]\n          );\n        }\n      } else if (property === 'shadow') {\n        let shadowProps = theme[themePropertyMap[property]](colorModeProps)[\n          props[property]\n        ];\n        if (!isNil(shadowProps)) {\n          newProps = { ...newProps, ...shadowProps };\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(\n          props[property],\n          currentBreakpoint,\n          property\n        );\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(\n        props[property],\n        currentBreakpoint,\n        property\n      );\n    }\n  }\n  return cloneDeep(newProps);\n}\n\n/*\nRemove props from defaultProps that are already present in props\n*/\nfunction filterDefaultProps(props: any, defaultProps: any) {\n  let [, resultProps] = extractInObject(defaultProps, Object.keys(props));\n  return resultProps;\n}\n\n/**\n * If property is functional in componentTheme, get its returned object\n *\n * @param property : name of the prop\n * @param props : all props\n * @param theme : provided theme without components\n * @param componentTheme : component specific theme\n * @returns\n */\nexport const extractPropertyFromFunction = (\n  property: string,\n  props: any,\n  theme: any,\n  componentTheme: any\n) => {\n  let propValues;\n  // Check if the entry in the theme is a function then calling it with all theme and props as params\n  if (\n    componentTheme &&\n    typeof componentTheme[themePropertyMap[property]] === 'function'\n  ) {\n    let funcProps = componentTheme[themePropertyMap[property]]({\n      theme,\n      ...props,\n    });\n    // Check if returned object from componentTheme is a nested object\n    let isNested: boolean = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    });\n    // If the returned value is nested object then find the property value in it, otherwise return the whole object\n    propValues = isNested\n      ? { ...get(funcProps, `${props[property]}`) }\n      : { ...funcProps };\n  } else {\n    // If the entry is any value other than function then return the whole object or value\n    propValues = get(\n      componentTheme,\n      `${themePropertyMap[property]}.${props[property]}`\n    );\n  }\n  return propValues;\n};\n\n/*\nMerge _props and apply contrastText color if not passed by theme or user\n*/\nexport function mergeUnderscoreProps(newProps: any, props: any) {\n  const _props = Object.keys(newProps).filter((propName) =>\n    propName.startsWith('_')\n  );\n  _props.forEach((propName: string) => {\n    // Adding color based on bg contrast if no color is given\n    const bg = newProps.bg ?? newProps.backgroundColor;\n    const textColor = bg\n      ? {\n          color: useContrastText(\n            bg,\n            newProps[propName]?.color ?? props[propName]?.color\n          ),\n        }\n      : {};\n    // Overriding calculated props with user added props\n    newProps[propName] = {\n      ...textColor,\n      ...newProps[propName],\n      ...props[propName],\n    };\n  });\n  return newProps;\n}\n\n/**\n *\n * Checks the property and resolves it if it has breakpoints\n * @param values : value from props\n * @param currentBreakpoint : current value for which breakpoint will be calculated\n * @param property : property name\n * @returns\n */\nexport const resolveValueWithBreakpoint = (\n  values: any,\n  currentBreakpoint: number,\n  property: any\n) => {\n  if (hasValidBreakpointFormat(values, property)) {\n    // Check the last valid breakpoint value from all values\n    // If current breakpoint is `md` and we have `base` then `lg`, then last value will be taken(`base` in this case)\n    return findLastValidBreakpoint(values, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\n\n/**\n * Takes all prop related data and returns the props that needs to be applied to the component\n *\n * @param theme Theme object\n * @param colorModeProps Color mode information\n * @param componentTheme Theme object for the specific component\n * @param props Props passed by the user\n * @param windowWidth Width of the current window\n * @returns props to be applied\n */\nexport function calculateProps(\n  theme: any,\n  colorModeProps: any,\n  componentTheme: any,\n  props: any,\n  windowWidth: any\n) {\n  let currentBreakpoint = getClosestBreakpoint(theme.breakpoints, windowWidth);\n  if (!props) {\n    props = {};\n  }\n\n  let newProps: any;\n  if (componentTheme) {\n    // Extracting props from defaultProps\n    newProps = extractProps(\n      filterDefaultProps(props, componentTheme.defaultProps),\n      theme,\n      colorModeProps,\n      componentTheme,\n      currentBreakpoint\n    );\n    // Extracting props from base style\n    let componentBaseStyle =\n      typeof componentTheme.baseStyle !== 'function'\n        ? componentTheme.baseStyle\n        : componentTheme.baseStyle({\n            theme,\n            ...newProps,\n            ...props,\n            ...colorModeProps,\n          });\n    newProps = mergeWith(\n      newProps,\n      componentBaseStyle,\n      // @ts-ignore\n      (objValue, srcValue, key) => {\n        if (!isNil(objValue)) {\n          delete newProps[key];\n        }\n      }\n    );\n\n    const variant =\n      props.variant || get(componentTheme, 'defaultProps.variant');\n    // Extracting props from variant\n    if (\n      variant &&\n      componentTheme.variants &&\n      componentTheme.variants[variant]\n    ) {\n      const colorScheme =\n        props.colorScheme || get(componentTheme, 'defaultProps.colorScheme');\n      let variantProps = componentTheme.variants[variant]({\n        ...props,\n        ...newProps,\n        colorScheme,\n        theme,\n        ...colorModeProps,\n      });\n      variantProps = extractProps(\n        variantProps,\n        theme,\n        colorModeProps,\n        componentTheme,\n        currentBreakpoint\n      );\n      // added this to handle order of props\n      newProps = mergeWith(\n        newProps,\n        variantProps,\n        // @ts-ignore\n        (objValue, srcValue, key) => {\n          if (!isNil(objValue)) {\n            delete newProps[key];\n          }\n        }\n      );\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  }\n  // Extracting props from normal props\n  let extractedProps = extractProps(\n    props,\n    theme,\n    colorModeProps,\n    componentTheme,\n    currentBreakpoint\n  );\n  // added this to handle order of props\n  // @ts-ignore\n  newProps = mergeWith(newProps, extractedProps, (objValue, srcValue, key) => {\n    if (!isNil(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}\n"]},"metadata":{},"sourceType":"script"}