{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useRef, useState } from \"react\";\nimport { useControlledState } from \"@react-stately/utils\";\nimport { clamp, snapValueToStep } from \"@react-aria/utils\";\nvar $dcc38d2f5fc04b76254f325fa36d$var$DEFAULT_MIN_VALUE = 0;\nvar $dcc38d2f5fc04b76254f325fa36d$var$DEFAULT_MAX_VALUE = 100;\nvar $dcc38d2f5fc04b76254f325fa36d$var$DEFAULT_STEP_VALUE = 1;\nexport function useSliderState(props) {\n  var _props$defaultValue;\n\n  var isDisabled = props.isDisabled,\n      _props$minValue = props.minValue,\n      minValue = _props$minValue === void 0 ? $dcc38d2f5fc04b76254f325fa36d$var$DEFAULT_MIN_VALUE : _props$minValue,\n      _props$maxValue = props.maxValue,\n      maxValue = _props$maxValue === void 0 ? $dcc38d2f5fc04b76254f325fa36d$var$DEFAULT_MAX_VALUE : _props$maxValue,\n      formatter = props.numberFormatter,\n      _props$step = props.step,\n      step = _props$step === void 0 ? $dcc38d2f5fc04b76254f325fa36d$var$DEFAULT_STEP_VALUE : _props$step;\n\n  var _useControlledState = useControlledState(props.value, (_props$defaultValue = props.defaultValue) != null ? _props$defaultValue : [minValue], props.onChange),\n      _useControlledState2 = _slicedToArray(_useControlledState, 2),\n      values = _useControlledState2[0],\n      setValues = _useControlledState2[1];\n\n  var _useState = useState(new Array(values.length).fill(false)),\n      _useState2 = _slicedToArray(_useState, 2),\n      isDraggings = _useState2[0],\n      setDraggings = _useState2[1];\n\n  var isEditablesRef = useRef(new Array(values.length).fill(true));\n\n  var _useState3 = useState(undefined),\n      _useState4 = _slicedToArray(_useState3, 2),\n      focusedIndex = _useState4[0],\n      setFocusedIndex = _useState4[1];\n\n  var valuesRef = useRef(null);\n  valuesRef.current = values;\n  var isDraggingsRef = useRef(null);\n  isDraggingsRef.current = isDraggings;\n\n  function getValuePercent(value) {\n    return (value - minValue) / (maxValue - minValue);\n  }\n\n  function getThumbMinValue(index) {\n    return index === 0 ? minValue : values[index - 1];\n  }\n\n  function getThumbMaxValue(index) {\n    return index === values.length - 1 ? maxValue : values[index + 1];\n  }\n\n  function isThumbEditable(index) {\n    return isEditablesRef.current[index];\n  }\n\n  function setThumbEditable(index, editable) {\n    isEditablesRef.current[index] = editable;\n  }\n\n  function updateValue(index, value) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n\n    var thisMin = getThumbMinValue(index);\n    var thisMax = getThumbMaxValue(index);\n    value = snapValueToStep(value, thisMin, thisMax, step);\n    valuesRef.current = $dcc38d2f5fc04b76254f325fa36d$var$replaceIndex(valuesRef.current, index, value);\n    setValues(valuesRef.current);\n  }\n\n  function updateDragging(index, dragging) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n\n    var wasDragging = isDraggingsRef.current[index];\n    isDraggingsRef.current = $dcc38d2f5fc04b76254f325fa36d$var$replaceIndex(isDraggingsRef.current, index, dragging);\n    setDraggings(isDraggingsRef.current);\n\n    if (props.onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) {\n      props.onChangeEnd(valuesRef.current);\n    }\n  }\n\n  function getFormattedValue(value) {\n    return formatter.format(value);\n  }\n\n  function setThumbPercent(index, percent) {\n    updateValue(index, getPercentValue(percent));\n  }\n\n  function getRoundedValue(value) {\n    return Math.round((value - minValue) / step) * step + minValue;\n  }\n\n  function getPercentValue(percent) {\n    var val = percent * (maxValue - minValue) + minValue;\n    return clamp(getRoundedValue(val), minValue, maxValue);\n  }\n\n  return {\n    values: values,\n    getThumbValue: function getThumbValue(index) {\n      return values[index];\n    },\n    setThumbValue: updateValue,\n    setThumbPercent: setThumbPercent,\n    isThumbDragging: function isThumbDragging(index) {\n      return isDraggings[index];\n    },\n    setThumbDragging: updateDragging,\n    focusedThumb: focusedIndex,\n    setFocusedThumb: setFocusedIndex,\n    getThumbPercent: function getThumbPercent(index) {\n      return getValuePercent(values[index]);\n    },\n    getValuePercent: getValuePercent,\n    getThumbValueLabel: function getThumbValueLabel(index) {\n      return getFormattedValue(values[index]);\n    },\n    getFormattedValue: getFormattedValue,\n    getThumbMinValue: getThumbMinValue,\n    getThumbMaxValue: getThumbMaxValue,\n    getPercentValue: getPercentValue,\n    isThumbEditable: isThumbEditable,\n    setThumbEditable: setThumbEditable,\n    step: step\n  };\n}\n\nfunction $dcc38d2f5fc04b76254f325fa36d$var$replaceIndex(array, index, value) {\n  if (array[index] === value) {\n    return array;\n  }\n\n  return [].concat(_toConsumableArray(array.slice(0, index)), [value], _toConsumableArray(array.slice(index + 1)));\n}","map":{"version":3,"sources":["packages/@react-stately/slider/src/useSliderState.ts"],"names":["DEFAULT_MIN_VALUE","DEFAULT_MAX_VALUE","DEFAULT_STEP_VALUE","minValue","maxValue","numberFormatter","step","useControlledState","props","useState","values","isEditablesRef","useRef","valuesRef","isDraggingsRef","value","index","isDisabled","isThumbEditable","thisMin","getThumbMinValue","thisMax","getThumbMaxValue","snapValueToStep","replaceIndex","setValues","wasDragging","setDraggings","formatter","updateValue","getPercentValue","Math","val","percent","clamp","getRoundedValue","getThumbValue","setThumbValue","setThumbPercent","isThumbDragging","isDraggings","setThumbDragging","focusedThumb","setFocusedThumb","getThumbPercent","getValuePercent","getThumbValueLabel","getFormattedValue","setThumbEditable","array"],"mappings":";;;;;AA+HA,IAAMA,mDAAiB,GAAvB,CAAA;AACA,IAAMC,mDAAiB,GAAvB,GAAA;AACA,IAAMC,oDAAkB,GAAxB,CAAA;OAYO,SAAA,cAAA,CAAA,KAAA,EAAgE;AAAA,MAAA,mBAAA;;AACrE,MAAM,UAAN,GAAA,KAAA,CAAM,UAAN;AAAA,wBAAA,KAAA,CAAmBC,QAAnB;AAAA,MAAmBA,QAAnB,gCAAM,mDAAN;AAAA,wBAAA,KAAA,CAAiDC,QAAjD;AAAA,MAAiDA,QAAjD,gCAAM,mDAAN;AAAA,MAAM,SAAN,GAAA,KAAA,CAA+EC,eAA/E;AAAA,oBAAA,KAAA,CAA2GC,IAA3G;AAAA,MAA2GA,IAA3G,4BAAkHJ,oDAAlH;;AAEA,4BAA4BK,kBAAkB,CAC5CC,KAAK,CADuC,KAAA,EAAA,CAAA,mBAAA,GAE5CA,KAAK,CAFuC,YAAA,KAAA,IAAA,GAAA,mBAAA,GAEtB,CAFsB,QAEtB,CAFsB,EAG5CA,KAAK,CAHP,QAA8C,CAA9C;AAAA;AAAA,MAAM,MAAN;AAAA,MAAM,SAAN;;AAKA,kBAAoCC,QAAQ,CAAY,IAAA,KAAA,CAAUC,MAAM,CAAhB,MAAA,EAAA,IAAA,CAAxD,KAAwD,CAAZ,CAA5C;AAAA;AAAA,MAAM,WAAN;AAAA,MAAM,YAAN;;AACA,MAAMC,cAAc,GAAGC,MAAM,CAAY,IAAA,KAAA,CAAUF,MAAM,CAAhB,MAAA,EAAA,IAAA,CAAzC,IAAyC,CAAZ,CAA7B;;AACA,mBAAwCD,QAAQ,CAAhD,SAAgD,CAAhD;AAAA;AAAA,MAAM,YAAN;AAAA,MAAM,eAAN;;AAEA,MAAMI,SAAS,GAAGD,MAAM,CAAxB,IAAwB,CAAxB;AACAC,EAAAA,SAAS,CAATA,OAAAA,GAAAA,MAAAA;AACA,MAAMC,cAAc,GAAGF,MAAM,CAA7B,IAA6B,CAA7B;AACAE,EAAAA,cAAc,CAAdA,OAAAA,GAAAA,WAAAA;;AAEA,WAAA,eAAA,CAAA,KAAA,EAAwC;AACtC,WAAO,CAACC,KAAK,GAAN,QAAA,KAAsBX,QAAQ,GAArC,QAAO,CAAP;AACD;;AAED,WAAA,gBAAA,CAAA,KAAA,EAAyC;AACvC,WAAOY,KAAK,KAALA,CAAAA,GAAAA,QAAAA,GAAyBN,MAAM,CAACM,KAAK,GAA5C,CAAsC,CAAtC;AACD;;AACD,WAAA,gBAAA,CAAA,KAAA,EAAyC;AACvC,WAAOA,KAAK,KAAKN,MAAM,CAANA,MAAAA,GAAVM,CAAAA,GAAAA,QAAAA,GAAyCN,MAAM,CAACM,KAAK,GAA5D,CAAsD,CAAtD;AACD;;AAED,WAAA,eAAA,CAAA,KAAA,EAAwC;AACtC,WAAOL,cAAc,CAAdA,OAAAA,CAAP,KAAOA,CAAP;AACD;;AAED,WAAA,gBAAA,CAAA,KAAA,EAAA,QAAA,EAA4D;AAC1DA,IAAAA,cAAc,CAAdA,OAAAA,CAAAA,KAAAA,IAAAA,QAAAA;AACD;;AAED,WAAA,WAAA,CAAA,KAAA,EAAA,KAAA,EAAmD;AACjD,QAAIM,UAAU,IAAI,CAACC,eAAe,CAAlC,KAAkC,CAAlC,EAA2C;AACzC;AACD;;AACD,QAAMC,OAAO,GAAGC,gBAAgB,CAAhC,KAAgC,CAAhC;AACA,QAAMC,OAAO,GAAGC,gBAAgB,CALiB,KAKjB,CAAhC;AAGAP,IAAAA,KAAK,GAAGQ,eAAe,CAAA,KAAA,EAAA,OAAA,EAAA,OAAA,EAAvBR,IAAuB,CAAvBA;AACAF,IAAAA,SAAS,CAATA,OAAAA,GAAoBW,8CAAY,CAACX,SAAS,CAAV,OAAA,EAAA,KAAA,EAAhCA,KAAgC,CAAhCA;AACAY,IAAAA,SAAS,CAACZ,SAAS,CAAnBY,OAAS,CAATA;AACD;;AAED,WAAA,cAAA,CAAA,KAAA,EAAA,QAAA,EAA0D;AACxD,QAAIR,UAAU,IAAI,CAACC,eAAe,CAAlC,KAAkC,CAAlC,EAA2C;AACzC;AACD;;AAED,QAAMQ,WAAW,GAAGZ,cAAc,CAAdA,OAAAA,CAApB,KAAoBA,CAApB;AACAA,IAAAA,cAAc,CAAdA,OAAAA,GAAyBU,8CAAY,CAACV,cAAc,CAAf,OAAA,EAAA,KAAA,EAArCA,QAAqC,CAArCA;AACAa,IAAAA,YAAY,CAACb,cAAc,CAP6B,OAO5C,CAAZa;;AAGA,QAAInB,KAAK,CAALA,WAAAA,IAAAA,WAAAA,IAAoC,CAACM,cAAc,CAAdA,OAAAA,CAAAA,IAAAA,CAAzC,OAAyCA,CAAzC,EAA+E;AAC7EN,MAAAA,KAAK,CAALA,WAAAA,CAAkBK,SAAS,CAA3BL,OAAAA;AACD;AACF;;AAED,WAAA,iBAAA,CAAA,KAAA,EAA0C;AACxC,WAAOoB,SAAS,CAATA,MAAAA,CAAP,KAAOA,CAAP;AACD;;AAED,WAAA,eAAA,CAAA,KAAA,EAAA,OAAA,EAAyD;AACvDC,IAAAA,WAAW,CAAA,KAAA,EAAQC,eAAe,CAAlCD,OAAkC,CAAvB,CAAXA;AACD;;AAED,WAAA,eAAA,CAAA,KAAA,EAAwC;AACtC,WAAOE,IAAI,CAAJA,KAAAA,CAAW,CAAChB,KAAK,GAAN,QAAA,IAAXgB,IAAAA,IAAAA,IAAAA,GAAP,QAAA;AACD;;AAED,WAAA,eAAA,CAAA,OAAA,EAA0C;AACxC,QAAMC,GAAG,GAAGC,OAAO,IAAI7B,QAAQ,GAAnB6B,QAAO,CAAPA,GAAZ,QAAA;AACA,WAAOC,KAAK,CAACC,eAAe,CAAhB,GAAgB,CAAhB,EAAA,QAAA,EAAZ,QAAY,CAAZ;AACD;;AAED,SAAO;AACLzB,IAAAA,MAAM,EADD,MAAA;AAEL0B,IAAAA,aAAa,EAAGpB,uBAAAA,KAAD;AAAA,aAAmBN,MAAM,CAFnC,KAEmC,CAAzB;AAAA,KAFV;AAGL2B,IAAAA,aAAa,EAHR,WAAA;AAILC,IAAAA,eAJK,EAILA,eAJK;AAKLC,IAAAA,eAAe,EAAGvB,yBAAAA,KAAD;AAAA,aAAmBwB,WAAW,CAL1C,KAK0C,CAA9B;AAAA,KALZ;AAMLC,IAAAA,gBAAgB,EANX,cAAA;AAOLC,IAAAA,YAAY,EAPP,YAAA;AAQLC,IAAAA,eAAe,EARV,eAAA;AASLC,IAAAA,eAAe,EAAG5B,yBAAAA,KAAD;AAAA,aAAmB6B,eAAe,CAACnC,MAAM,CATrD,KASqD,CAAP,CAAlC;AAAA,KATZ;AAULmC,IAAAA,eAVK,EAULA,eAVK;AAWLC,IAAAA,kBAAkB,EAAG9B,4BAAAA,KAAD;AAAA,aAAmB+B,iBAAiB,CAACrC,MAAM,CAX1D,KAW0D,CAAP,CAApC;AAAA,KAXf;AAYLqC,IAAAA,iBAZK,EAYLA,iBAZK;AAaL3B,IAAAA,gBAbK,EAaLA,gBAbK;AAcLE,IAAAA,gBAdK,EAcLA,gBAdK;AAeLQ,IAAAA,eAfK,EAeLA,eAfK;AAgBLZ,IAAAA,eAhBK,EAgBLA,eAhBK;AAiBL8B,IAAAA,gBAjBK,EAiBLA,gBAjBK;AAkBL1C,IAAAA,IAAAA,EAAAA;AAlBK,GAAP;AAoBD;;AAED,SAAA,8CAAA,CAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAA8D;AAC5D,MAAI2C,KAAK,CAALA,KAAK,CAALA,KAAJ,KAAA,EAA4B;AAC1B,WAAA,KAAA;AACD;;AAED,sCAAWA,KAAK,CAALA,KAAAA,CAAAA,CAAAA,EAAJ,KAAIA,CAAX,IAAO,KAAP,sBAA4CA,KAAK,CAALA,KAAAA,CAAYjC,KAAK,GAA7D,CAA4CiC,CAA5C;AACD","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep} from '@react-aria/utils';\nimport {SliderProps} from '@react-types/slider';\nimport {useControlledState} from '@react-stately/utils';\nimport {useRef, useState} from 'react';\n\nexport interface SliderState {\n  /**\n   * Values managed by the slider by thumb index.\n   */\n  readonly values: number[],\n  /**\n   * Get the value for the specified thumb.\n   * @param index\n   */\n  getThumbValue(index: number): number,\n\n  /**\n   * Sets the value for the specified thumb.\n   * The actual value set will be clamped and rounded according to min/max/step.\n   * @param index\n   * @param value\n   */\n  setThumbValue(index: number, value: number): void,\n\n  /**\n   * Sets value for the specified thumb by percent offset (between 0 and 1).\n   * @param index\n   * @param percent\n   */\n  setThumbPercent(index: number, percent: number): void,\n\n  /**\n   * Whether the specific thumb is being dragged.\n   * @param index\n   */\n  isThumbDragging(index: number): boolean,\n  /**\n   * Set is dragging on the specified thumb.\n   * @param index\n   * @param dragging\n   */\n  setThumbDragging(index: number, dragging: boolean): void,\n\n  /**\n   * Currently-focused thumb index.\n   */\n  readonly focusedThumb: number | undefined,\n  /**\n   * Set focused true on specified thumb. This will remove focus from\n   * any thumb that had it before.\n   * @param index\n   */\n  setFocusedThumb(index: number | undefined): void,\n\n  /**\n   * Returns the specified thumb's value as a percentage from 0 to 1.\n   * @param index\n   */\n  getThumbPercent(index: number): number,\n\n  /**\n   * Returns the value as a percent between the min and max of the slider.\n   * @param index\n   */\n  getValuePercent(value: number): number,\n\n  /**\n   * Returns the string label for the specified thumb's value, per props.formatOptions.\n   * @param index\n   */\n  getThumbValueLabel(index: number): string,\n\n  /**\n   * Returns the string label for the value, per props.formatOptions.\n   * @param index\n   */\n  getFormattedValue(value: number): string,\n\n  /**\n   * Returns the min allowed value for the specified thumb.\n   * @param index\n   */\n  getThumbMinValue(index: number): number,\n\n  /**\n   * Returns the max allowed value for the specified thumb.\n   * @param index\n   */\n  getThumbMaxValue(index: number): number,\n\n  /**\n   * Converts a percent along track (between 0 and 1) to the corresponding value.\n   * @param percent\n   */\n  getPercentValue(percent: number): number,\n\n  /**\n   * Returns if the specified thumb is editable.\n   * @param index\n   */\n  isThumbEditable(index: number): boolean,\n\n  /**\n   * Set the specified thumb's editable state.\n   * @param index\n   * @param editable\n   */\n  setThumbEditable(index: number, editable: boolean): void,\n\n  /**\n   * The step amount for the slider.\n   */\n  readonly step: number\n}\n\nconst DEFAULT_MIN_VALUE = 0;\nconst DEFAULT_MAX_VALUE = 100;\nconst DEFAULT_STEP_VALUE = 1;\n\ninterface SliderStateOptions extends SliderProps {\n  numberFormatter: Intl.NumberFormat\n}\n\n/**\n * Provides state management for a slider component. Stores values for all thumbs,\n * formats values for localization, and provides methods to update the position\n * of any thumbs.\n * @param props\n */\nexport function useSliderState(props: SliderStateOptions): SliderState {\n  const {isDisabled, minValue = DEFAULT_MIN_VALUE, maxValue = DEFAULT_MAX_VALUE, numberFormatter: formatter, step = DEFAULT_STEP_VALUE} = props;\n\n  const [values, setValues] = useControlledState<number[]>(\n    props.value as any,\n    props.defaultValue ?? [minValue] as any,\n    props.onChange as any\n  );\n  const [isDraggings, setDraggings] = useState<boolean[]>(new Array(values.length).fill(false));\n  const isEditablesRef = useRef<boolean[]>(new Array(values.length).fill(true));\n  const [focusedIndex, setFocusedIndex] = useState<number | undefined>(undefined);\n\n  const valuesRef = useRef<number[]>(null);\n  valuesRef.current = values;\n  const isDraggingsRef = useRef<boolean[]>(null);\n  isDraggingsRef.current = isDraggings;\n\n  function getValuePercent(value: number) {\n    return (value - minValue) / (maxValue - minValue);\n  }\n\n  function getThumbMinValue(index: number) {\n    return index === 0 ? minValue : values[index - 1];\n  }\n  function getThumbMaxValue(index: number) {\n    return index === values.length - 1 ? maxValue : values[index + 1];\n  }\n\n  function isThumbEditable(index: number) {\n    return isEditablesRef.current[index];\n  }\n\n  function setThumbEditable(index: number, editable: boolean) {\n    isEditablesRef.current[index] = editable;\n  }\n\n  function updateValue(index: number, value: number) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n    const thisMin = getThumbMinValue(index);\n    const thisMax = getThumbMaxValue(index);\n\n    // Round value to multiple of step, clamp value between min and max\n    value = snapValueToStep(value, thisMin, thisMax, step);\n    valuesRef.current = replaceIndex(valuesRef.current, index, value);\n    setValues(valuesRef.current);\n  }\n\n  function updateDragging(index: number, dragging: boolean) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n\n    const wasDragging = isDraggingsRef.current[index];\n    isDraggingsRef.current = replaceIndex(isDraggingsRef.current, index, dragging);\n    setDraggings(isDraggingsRef.current);\n\n    // Call onChangeEnd if no handles are dragging.\n    if (props.onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) {\n      props.onChangeEnd(valuesRef.current);\n    }\n  }\n\n  function getFormattedValue(value: number) {\n    return formatter.format(value);\n  }\n\n  function setThumbPercent(index: number, percent: number) {\n    updateValue(index, getPercentValue(percent));\n  }\n\n  function getRoundedValue(value: number) {\n    return Math.round((value - minValue) / step) * step + minValue;\n  }\n\n  function getPercentValue(percent: number) {\n    const val = percent * (maxValue - minValue) + minValue;\n    return clamp(getRoundedValue(val), minValue, maxValue);\n  }\n\n  return {\n    values: values,\n    getThumbValue: (index: number) => values[index],\n    setThumbValue: updateValue,\n    setThumbPercent,\n    isThumbDragging: (index: number) => isDraggings[index],\n    setThumbDragging: updateDragging,\n    focusedThumb: focusedIndex,\n    setFocusedThumb: setFocusedIndex,\n    getThumbPercent: (index: number) => getValuePercent(values[index]),\n    getValuePercent,\n    getThumbValueLabel: (index: number) => getFormattedValue(values[index]),\n    getFormattedValue,\n    getThumbMinValue,\n    getThumbMaxValue,\n    getPercentValue,\n    isThumbEditable,\n    setThumbEditable,\n    step\n  };\n}\n\nfunction replaceIndex<T>(array: T[], index: number, value: T) {\n  if (array[index] === value) {\n    return array;\n  }\n\n  return [...array.slice(0, index), value, ...array.slice(index + 1)];\n}\n"]},"metadata":{},"sourceType":"module"}