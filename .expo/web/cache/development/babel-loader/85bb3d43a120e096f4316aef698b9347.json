{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.omitUndefined = omitUndefined;\nexports.getRandomString = getRandomString;\nexports.orderedExtractInObject = orderedExtractInObject;\nexports.extractInObject = extractInObject;\nexports.getColorFormColorScheme = getColorFormColorScheme;\nexports.getColorScheme = getColorScheme;\nexports.hasValidBreakpointFormat = hasValidBreakpointFormat;\nexports.findLastValidBreakpoint = findLastValidBreakpoint;\nexports.getClosestBreakpoint = getClosestBreakpoint;\nexports.inValidBreakpointProps = exports.breakpoints = exports.stylingProps = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash.omitby\"));\n\nvar _lodash2 = _interopRequireDefault(require(\"lodash.isnil\"));\n\nvar _lodash3 = _interopRequireDefault(require(\"lodash.pick\"));\n\nvar _lodash4 = _interopRequireDefault(require(\"lodash.omit\"));\n\nvar stylingProps = {\n  margin: ['margin', 'm', 'marginTop', 'mt', 'marginRight', 'mr', 'marginBottom', 'mb', 'marginLeft', 'ml', 'marginX', 'mx', 'marginY', 'my'],\n  padding: ['padding', 'p', 'paddingTop', 'pt', 'paddingRight', 'pr', 'paddingBottom', 'pb', 'paddingLeft', 'pl', 'paddingX', 'px', 'paddingY', 'py'],\n  border: ['border', 'borderWidth', 'borderStyle', 'borderColor', 'borderRadius', 'borderTop', 'borderTopWidth', 'borderTopStyle', 'borderTopColor', 'borderTopLeftRadius', 'borderTopRightRadius', 'borderRight', 'borderRightWidth', 'borderRightStyle', 'borderRightColor', 'borderBottom', 'borderBottomWidth', 'borderBottomStyle', 'borderBottomColor', 'borderBottomLeftRadius', 'borderBottomRightRadius', 'borderLeft', 'borderLeftWidth', 'borderLeftStyle', 'borderLeftColor', 'borderX', 'borderY'],\n  layout: ['width', 'w', 'height', 'h', 'display', 'minWidth', 'minW', 'minH', 'minHeight', 'maxWidth', 'maxW', 'maxHeight', 'maxH', 'size', 'verticalAlign', 'overflow', 'overflowX', 'overflowY'],\n  flexbox: ['alignItems', 'alignContent', 'justifyItems', 'justifyContent', 'flexWrap', 'flexDirection', 'flex', 'flexGrow', 'flexShrink', 'flexBasis', 'justifySelf', 'alignSelf', 'order'],\n  position: ['position', 'zIndex', 'top', 'right', 'bottom', 'left'],\n  background: ['bg', 'backgroundColor']\n};\nexports.stylingProps = stylingProps;\n\nfunction omitUndefined(obj) {\n  return (0, _lodash.default)(obj, _lodash2.default);\n}\n\nfunction getRandomString(length) {\n  var result = '';\n  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  var charactersLength = characters.length;\n\n  for (var i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  return result;\n}\n\nfunction orderedPick(obj, values) {\n  var ret = {};\n  Object.keys(obj).forEach(function (key) {\n    if (values.includes(key)) {\n      ret[key] = obj[key];\n    }\n  });\n  return ret;\n}\n\nfunction orderedExtractInObject(parent, values) {\n  return [omitUndefined(orderedPick(parent, values)), omitUndefined((0, _lodash4.default)(parent, values))];\n}\n\nfunction extractInObject(parent, values) {\n  return [omitUndefined((0, _lodash3.default)(parent, values)), omitUndefined((0, _lodash4.default)(parent, values))];\n}\n\nfunction getColorFormColorScheme(props) {\n  var theme = props.theme,\n      colorScheme = props.colorScheme,\n      isDisabled = props.isDisabled;\n  var simpleColorScheme = colorScheme.split('.')[0];\n  if (isDisabled) return 'gray.300';else if (simpleColorScheme in theme.colors) {\n    return theme.colors[simpleColorScheme][0] === '#' ? simpleColorScheme : theme.colors[simpleColorScheme][400] || theme.colors[simpleColorScheme][200];\n  } else return 'primary.200';\n}\n\nfunction getColorScheme(props, customColorScheme) {\n  var theme = props.theme,\n      colorScheme = props.colorScheme;\n  colorScheme = customColorScheme || colorScheme;\n  if (!(colorScheme in theme.colors)) return 'primary';else {\n    if (typeof theme.colors[colorScheme] === 'object') return colorScheme;\n  }\n}\n\nvar breakpoints = Object.freeze(['base', 'sm', 'md', 'lg', 'xl']);\nexports.breakpoints = breakpoints;\nvar inValidBreakpointProps = ['style', 'children', 'shadowOffset'];\nexports.inValidBreakpointProps = inValidBreakpointProps;\n\nfunction hasValidBreakpointFormat(breaks, property) {\n  if (property && inValidBreakpointProps.indexOf(property) !== -1) {\n    return false;\n  } else if (Array.isArray(breaks)) {\n    return breaks.length ? true : false;\n  } else if (typeof breaks === 'object') {\n    var keys = Object.keys(breaks);\n\n    for (var i = 0; i < keys.length; i++) {\n      if (breakpoints.indexOf(keys[i]) === -1) {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction findLastValidBreakpoint(values, currentBreakpoint) {\n  var _valArray$currentBrea;\n\n  var valArray = Array.isArray(values) ? values : breakpoints.map(function (bPoint) {\n    return values[bPoint];\n  });\n  return (_valArray$currentBrea = valArray[currentBreakpoint]) != null ? _valArray$currentBrea : valArray.slice(0, currentBreakpoint + 1).filter(function (v) {\n    return !(0, _lodash2.default)(v);\n  }).pop();\n}\n\nfunction getClosestBreakpoint(values, point) {\n  var dimValues = Object.values(values);\n  var index = -1;\n\n  for (var i = 0; i < dimValues.length; i++) {\n    if (dimValues[i] === point) {\n      index = i;\n      break;\n    } else if (dimValues[i] > point && i !== 0) {\n      index = i - 1;\n      break;\n    } else if (dimValues[i] < point && i === dimValues.length - 1) {\n      index = i;\n      break;\n    }\n  }\n\n  return index;\n}","map":{"version":3,"sources":["utils.ts"],"names":["stylingProps","margin","padding","border","layout","flexbox","position","background","isNil","result","characters","charactersLength","i","Math","ret","Object","values","obj","omitUndefined","orderedPick","theme","colorScheme","isDisabled","props","simpleColorScheme","customColorScheme","breakpoints","inValidBreakpointProps","property","Array","breaks","keys","valArray","currentBreakpoint","dimValues","index"],"mappings":";;;;;;;;;;;;;;;;AAAA,IAAA,OAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AACA,IAAA,QAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,IAAA,QAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,IAAA,QAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AAEO,IAAMA,YAAY,GAAG;AAC1BC,EAAAA,MAAM,EAAE,CAAA,QAAA,EAAA,GAAA,EAAA,WAAA,EAAA,IAAA,EAAA,aAAA,EAAA,IAAA,EAAA,cAAA,EAAA,IAAA,EAAA,YAAA,EAAA,IAAA,EAAA,SAAA,EAAA,IAAA,EAAA,SAAA,EADkB,IAClB,CADkB;AAiB1BC,EAAAA,OAAO,EAAE,CAAA,SAAA,EAAA,GAAA,EAAA,YAAA,EAAA,IAAA,EAAA,cAAA,EAAA,IAAA,EAAA,eAAA,EAAA,IAAA,EAAA,aAAA,EAAA,IAAA,EAAA,UAAA,EAAA,IAAA,EAAA,UAAA,EAjBiB,IAiBjB,CAjBiB;AAiC1BC,EAAAA,MAAM,EAAE,CAAA,QAAA,EAAA,aAAA,EAAA,aAAA,EAAA,aAAA,EAAA,cAAA,EAAA,WAAA,EAAA,gBAAA,EAAA,gBAAA,EAAA,gBAAA,EAAA,qBAAA,EAAA,sBAAA,EAAA,aAAA,EAAA,kBAAA,EAAA,kBAAA,EAAA,kBAAA,EAAA,cAAA,EAAA,mBAAA,EAAA,mBAAA,EAAA,mBAAA,EAAA,wBAAA,EAAA,yBAAA,EAAA,YAAA,EAAA,iBAAA,EAAA,iBAAA,EAAA,iBAAA,EAAA,SAAA,EAjCkB,SAiClB,CAjCkB;AA8D1BC,EAAAA,MAAM,EAAE,CAAA,OAAA,EAAA,GAAA,EAAA,QAAA,EAAA,GAAA,EAAA,SAAA,EAAA,UAAA,EAAA,MAAA,EAAA,MAAA,EAAA,WAAA,EAAA,UAAA,EAAA,MAAA,EAAA,WAAA,EAAA,MAAA,EAAA,MAAA,EAAA,eAAA,EAAA,UAAA,EAAA,WAAA,EA9DkB,WA8DlB,CA9DkB;AAkF1BC,EAAAA,OAAO,EAAE,CAAA,YAAA,EAAA,cAAA,EAAA,cAAA,EAAA,gBAAA,EAAA,UAAA,EAAA,eAAA,EAAA,MAAA,EAAA,UAAA,EAAA,YAAA,EAAA,WAAA,EAAA,aAAA,EAAA,WAAA,EAlFiB,OAkFjB,CAlFiB;AAiG1BC,EAAAA,QAAQ,EAAE,CAAA,UAAA,EAAA,QAAA,EAAA,KAAA,EAAA,OAAA,EAAA,QAAA,EAjGgB,MAiGhB,CAjGgB;AAkG1BC,EAAAA,UAAU,EAAE,CAAA,IAAA,EAlGP,iBAkGO;AAlGc,CAArB;;;AAqGA,SAAA,aAAA,CAAA,GAAA,EAAiC;AACtC,SAAO,CAAA,GAAA,OAAA,CAAA,OAAA,EAAA,GAAA,EAAYC,QAAAA,CAAnB,OAAO,CAAP;AAEK;;AAAA,SAAA,eAAA,CAAA,MAAA,EAAyC;AAC9C,MAAIC,MAAM,GAAV,EAAA;AACA,MAAIC,UAAU,GAAd,gEAAA;AAEA,MAAIC,gBAAgB,GAAGD,UAAU,CAAjC,MAAA;;AACA,OAAK,IAAIE,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,MAAA,EAA4BA,CAA5B,EAAA,EAAiC;AAC/BH,IAAAA,MAAM,IAAIC,UAAU,CAAVA,MAAAA,CAAkBG,IAAI,CAAJA,KAAAA,CAAWA,IAAI,CAAJA,MAAAA,KAAvCJ,gBAA4BI,CAAlBH,CAAVD;AAEF;;AAAA,SAAA,MAAA;AAGF;;AAAA,SAAA,WAAA,CAAA,GAAA,EAAA,MAAA,EAA4C;AAC1C,MAAIK,GAAQ,GAAZ,EAAA;AACAC,EAAAA,MAAM,CAANA,IAAAA,CAAAA,GAAAA,EAAAA,OAAAA,CAAyB,UAAA,GAAA,EAAiB;AACxC,QAAIC,MAAM,CAANA,QAAAA,CAAJ,GAAIA,CAAJ,EAA0B;AACxBF,MAAAA,GAAG,CAAHA,GAAG,CAAHA,GAAWG,GAAG,CAAdH,GAAc,CAAdA;AAEH;AAJDC,GAAAA;AAKA,SAAA,GAAA;AAEK;;AAAA,SAAA,sBAAA,CAAA,MAAA,EAAA,MAAA,EAAoE;AACzE,SAAO,CACLG,aAAa,CAACC,WAAW,CAAA,MAAA,EADpB,MACoB,CAAZ,CADR,EAELD,aAAa,CAAC,CAAA,GAAA,QAAA,CAAA,OAAA,EAAA,MAAA,EAFhB,MAEgB,CAAD,CAFR,CAAP;AAWK;;AAAA,SAAA,eAAA,CAAA,MAAA,EAAA,MAAA,EAA6D;AAClE,SAAO,CACLA,aAAa,CAAC,CAAA,GAAA,QAAA,CAAA,OAAA,EAAA,MAAA,EADT,MACS,CAAD,CADR,EAELA,aAAa,CAAC,CAAA,GAAA,QAAA,CAAA,OAAA,EAAA,MAAA,EAFhB,MAEgB,CAAD,CAFR,CAAP;AAKK;;AAAA,SAAA,uBAAA,CAAA,KAAA,EAA6D;AAAA,MAC1DE,KAD0D,GACvBG,KADuB,CAAA,KAAA;AAAA,MACnDF,WADmD,GACvBE,KADuB,CAAA,WAAA;AAAA,MACtCD,UADsC,GACvBC,KADuB,CAAA,UAAA;AAElE,MAAMC,iBAAiB,GAAGH,WAAW,CAAXA,KAAAA,CAAAA,GAAAA,EAA1B,CAA0BA,CAA1B;AACA,MAAA,UAAA,EAAgB,OAAhB,UAAgB,CAAhB,KACK,IAAIG,iBAAiB,IAAIJ,KAAK,CAA9B,MAAA,EAAuC;AAC1C,WAAOA,KAAK,CAALA,MAAAA,CAAAA,iBAAAA,EAAAA,CAAAA,MAAAA,GAAAA,GAAAA,iBAAAA,GAEHA,KAAK,CAALA,MAAAA,CAAAA,iBAAAA,EAAAA,GAAAA,KACEA,KAAK,CAALA,MAAAA,CAAAA,iBAAAA,EAHN,GAGMA,CAHN;AADG,GAAA,MAKE,OAAA,aAAA;AAIF;;AAAA,SAAA,cAAA,CAAA,KAAA,EAAA,iBAAA,EAGL;AAAA,MACMA,KADN,GAC6BG,KAD7B,CAAA,KAAA;AAAA,MACaF,WADb,GAC6BE,KAD7B,CAAA,WAAA;AAEAF,EAAAA,WAAW,GAAGI,iBAAiB,IAA/BJ,WAAAA;AACA,MAAI,EAAEA,WAAW,IAAID,KAAK,CAA1B,MAAI,CAAJ,EAAoC,OAApC,SAAoC,CAApC,KACK;AACH,QAAI,OAAOA,KAAK,CAALA,MAAAA,CAAP,WAAOA,CAAP,KAAJ,QAAA,EAAmD,OAAA,WAAA;AAEtD;AACM;;AAAA,IAAMM,WAAW,GAAGX,MAAM,CAANA,MAAAA,CAAc,CAAA,MAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAlC,IAAkC,CAAdA,CAApB;;AACA,IAAMY,sBAAsB,GAAG,CAAA,OAAA,EAAA,UAAA,EAA/B,cAA+B,CAA/B;;;AACA,SAAA,wBAAA,CAAA,MAAA,EAAA,QAAA,EAAkE;AACvE,MAAIC,QAAQ,IAAID,sBAAsB,CAAtBA,OAAAA,CAAAA,QAAAA,MAA6C,CAA7D,CAAA,EAAiE;AAC/D,WAAA,KAAA;AADF,GAAA,MAEO,IAAIE,KAAK,CAALA,OAAAA,CAAJ,MAAIA,CAAJ,EAA2B;AAChC,WAAOC,MAAM,CAANA,MAAAA,GAAAA,IAAAA,GAAP,KAAA;AADK,GAAA,MAEA,IAAI,OAAA,MAAA,KAAJ,QAAA,EAAgC;AACrC,QAAMC,IAAI,GAAGhB,MAAM,CAANA,IAAAA,CAAb,MAAaA,CAAb;;AACA,SAAK,IAAIH,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGmB,IAAI,CAAxB,MAAA,EAAiCnB,CAAjC,EAAA,EAAsC;AACpC,UAAIc,WAAW,CAAXA,OAAAA,CAAoBK,IAAI,CAAxBL,CAAwB,CAAxBA,MAAiC,CAArC,CAAA,EAAyC;AACvC,eAAA,KAAA;AAEH;AACD;;AAAA,WAAA,IAAA;AAPK,GAAA,MAQA;AACL,WAAA,KAAA;AAEH;AACM;;AAAA,SAAA,uBAAA,CAAA,MAAA,EAAA,iBAAA,EAGL;AAAA,MAAA,qBAAA;;AACA,MAAIM,QAAQ,GAAGH,KAAK,CAALA,OAAAA,CAAAA,MAAAA,IAAAA,MAAAA,GAEXH,WAAW,CAAXA,GAAAA,CAAgB,UAAA,MAAA,EAAA;AAAA,WAAoBV,MAAM,CAA1B,MAA0B,CAA1B;AAFpB,GAEIU,CAFJ;AAGA,SAAA,CAAA,qBAAA,GACEM,QAAQ,CADV,iBACU,CADV,KAAA,IAAA,GAAA,qBAAA,GAEEA,QAAQ,CAARA,KAAAA,CAAAA,CAAAA,EACYC,iBAAiB,GAD7BD,CAAAA,EAAAA,MAAAA,CAEU,UAAA,CAAA,EAAA;AAAA,WAAY,CAAC,CAAA,GAAA,QAAA,CAAA,OAAA,EAAb,CAAa,CAAb;AAFVA,GAAAA,EAFF,GAEEA,EAFF;AAQK;;AAAA,SAAA,oBAAA,CAAA,MAAA,EAAA,KAAA,EAGL;AACA,MAAIE,SAAS,GAAGnB,MAAM,CAANA,MAAAA,CAAhB,MAAgBA,CAAhB;AACA,MAAIoB,KAAK,GAAG,CAAZ,CAAA;;AACA,OAAK,IAAIvB,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGsB,SAAS,CAA7B,MAAA,EAAsCtB,CAAtC,EAAA,EAA2C;AACzC,QAAIsB,SAAS,CAATA,CAAS,CAATA,KAAJ,KAAA,EAA4B;AAC1BC,MAAAA,KAAK,GAALA,CAAAA;AACA;AAFF,KAAA,MAGO,IAAID,SAAS,CAATA,CAAS,CAATA,GAAAA,KAAAA,IAAwBtB,CAAC,KAA7B,CAAA,EAAqC;AAC1CuB,MAAAA,KAAK,GAAGvB,CAAC,GAATuB,CAAAA;AACA;AAFK,KAAA,MAKF,IAAID,SAAS,CAATA,CAAS,CAATA,GAAAA,KAAAA,IAAwBtB,CAAC,KAAKsB,SAAS,CAATA,MAAAA,GAAlC,CAAA,EAAwD;AAC3DC,MAAAA,KAAK,GAALA,CAAAA;AACA;AAEH;AACD;;AAAA,SAAA,KAAA;AACD","sourcesContent":["import omitBy from 'lodash.omitby';\nimport isNil from 'lodash.isnil';\nimport pick from 'lodash.pick';\nimport omit from 'lodash.omit';\n\nexport const stylingProps = {\n  margin: [\n    'margin',\n    'm',\n    'marginTop',\n    'mt',\n    'marginRight',\n    'mr',\n    'marginBottom',\n    'mb',\n    'marginLeft',\n    'ml',\n    'marginX',\n    'mx',\n    'marginY',\n    'my',\n  ],\n  padding: [\n    'padding',\n    'p',\n    'paddingTop',\n    'pt',\n    'paddingRight',\n    'pr',\n    'paddingBottom',\n    'pb',\n    'paddingLeft',\n    'pl',\n    'paddingX',\n    'px',\n    'paddingY',\n    'py',\n  ],\n  border: [\n    'border',\n    'borderWidth',\n    'borderStyle',\n    'borderColor',\n    'borderRadius',\n    'borderTop',\n    'borderTopWidth',\n    'borderTopStyle',\n    'borderTopColor',\n    'borderTopLeftRadius',\n    'borderTopRightRadius',\n    'borderRight',\n    'borderRightWidth',\n    'borderRightStyle',\n    'borderRightColor',\n    'borderBottom',\n    'borderBottomWidth',\n    'borderBottomStyle',\n    'borderBottomColor',\n    'borderBottomLeftRadius',\n    'borderBottomRightRadius',\n    'borderLeft',\n    'borderLeftWidth',\n    'borderLeftStyle',\n    'borderLeftColor',\n    'borderX',\n    'borderY',\n  ],\n  layout: [\n    'width',\n    'w',\n    'height',\n    'h',\n    'display',\n    'minWidth',\n    'minW',\n    'minH',\n    'minHeight',\n    'maxWidth',\n    'maxW',\n    'maxHeight',\n    'maxH',\n    'size',\n    'verticalAlign',\n    'overflow',\n    'overflowX',\n    'overflowY',\n  ],\n  flexbox: [\n    'alignItems',\n    'alignContent',\n    'justifyItems',\n    'justifyContent',\n    'flexWrap',\n    'flexDirection',\n    'flex',\n    'flexGrow',\n    'flexShrink',\n    'flexBasis',\n    'justifySelf',\n    'alignSelf',\n    'order',\n  ],\n  position: ['position', 'zIndex', 'top', 'right', 'bottom', 'left'],\n  background: ['bg', 'backgroundColor'],\n};\nexport type Dict = Record<string, any>;\nexport function omitUndefined(obj: any) {\n  return omitBy(obj, isNil);\n}\nexport function getRandomString(length: number) {\n  var result = '';\n  var characters =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  var charactersLength = characters.length;\n  for (var i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n// Inefficient way for pick, but retains order of props.\nfunction orderedPick(obj: any, values: any) {\n  let ret: any = {};\n  Object.keys(obj).forEach((key: string) => {\n    if (values.includes(key)) {\n      ret[key] = obj[key];\n    }\n  });\n  return ret;\n}\nexport function orderedExtractInObject(parent: any, values: Array<string>) {\n  return [\n    omitUndefined(orderedPick(parent, values)),\n    omitUndefined(omit(parent, values)),\n  ];\n}\n/**\n *\n * @param parent The object from which data needs to extracted\n * @param values Keys which needs to be extracted\n * @returns [extractedProps, remainingProps]\n */\nexport function extractInObject(parent: any, values: Array<string>) {\n  return [\n    omitUndefined(pick(parent, values)),\n    omitUndefined(omit(parent, values)),\n  ];\n}\nexport function getColorFormColorScheme(props: Record<string, any>) {\n  const { theme, colorScheme, isDisabled } = props;\n  const simpleColorScheme = colorScheme.split('.')[0];\n  if (isDisabled) return 'gray.300';\n  else if (simpleColorScheme in theme.colors) {\n    return theme.colors[simpleColorScheme][0] === '#'\n      ? simpleColorScheme\n      : theme.colors[simpleColorScheme][400] ||\n          theme.colors[simpleColorScheme][200];\n  } else return 'primary.200';\n}\n\n// TODO: This function can be removed.\nexport function getColorScheme(\n  props: Record<string, any>,\n  customColorScheme?: string\n) {\n  let { theme, colorScheme } = props;\n  colorScheme = customColorScheme || colorScheme;\n  if (!(colorScheme in theme.colors)) return 'primary';\n  else {\n    if (typeof theme.colors[colorScheme] === 'object') return colorScheme;\n  }\n}\nexport const breakpoints = Object.freeze(['base', 'sm', 'md', 'lg', 'xl']);\nexport const inValidBreakpointProps = ['style', 'children', 'shadowOffset'];\nexport function hasValidBreakpointFormat(breaks: any, property?: string) {\n  if (property && inValidBreakpointProps.indexOf(property) !== -1) {\n    return false;\n  } else if (Array.isArray(breaks)) {\n    return breaks.length ? true : false;\n  } else if (typeof breaks === 'object') {\n    const keys = Object.keys(breaks);\n    for (let i = 0; i < keys.length; i++) {\n      if (breakpoints.indexOf(keys[i]) === -1) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function findLastValidBreakpoint(\n  values: any,\n  currentBreakpoint: number\n) {\n  let valArray = Array.isArray(values)\n    ? values\n    : breakpoints.map((bPoint: string) => values[bPoint]);\n  return (\n    valArray[currentBreakpoint] ??\n    valArray\n      .slice(0, currentBreakpoint + 1)\n      .filter((v: any) => !isNil(v))\n      .pop()\n  );\n}\nexport function getClosestBreakpoint(\n  values: Record<string, any>,\n  point: number\n) {\n  let dimValues = Object.values(values);\n  let index = -1;\n  for (let i = 0; i < dimValues.length; i++) {\n    if (dimValues[i] === point) {\n      index = i;\n      break;\n    } else if (dimValues[i] > point && i !== 0) {\n      index = i - 1;\n      break;\n    }\n    // If windowWidth is greater than last available breakpoint clamp it to last index\n    else if (dimValues[i] < point && i === dimValues.length - 1) {\n      index = i;\n      break;\n    }\n  }\n  return index;\n}\n"]},"metadata":{},"sourceType":"script"}