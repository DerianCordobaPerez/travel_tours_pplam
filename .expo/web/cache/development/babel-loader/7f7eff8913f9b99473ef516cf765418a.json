{"ast":null,"code":"import { isFocusVisible, useHover, usePress } from \"@react-aria/interactions\";\nimport { getItemCount } from \"@react-stately/collections\";\nimport { useSelectableList, useSelectableItem } from \"@react-aria/selection\";\nimport _babelRuntimeHelpersEsmObjectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport { useOverlayTrigger } from \"@react-aria/overlays\";\nimport { useId, filterDOMProps, mergeProps, useSlotId } from \"@react-aria/utils\";\nimport _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\nexport function useMenuTrigger(props, state, ref) {\n  var _props$type = props.type,\n      type = _props$type === void 0 ? 'menu' : _props$type,\n      isDisabled = props.isDisabled;\n  var menuTriggerId = useId();\n\n  var _useOverlayTrigger = useOverlayTrigger({\n    type: type\n  }, state, ref),\n      triggerProps = _useOverlayTrigger.triggerProps,\n      overlayProps = _useOverlayTrigger.overlayProps;\n\n  var onKeyDown = function onKeyDown(e) {\n    if (typeof e.isDefaultPrevented === 'function' && e.isDefaultPrevented() || e.defaultPrevented || isDisabled) {\n      return;\n    }\n\n    if (ref && ref.current) {\n      switch (e.key) {\n        case 'ArrowDown':\n        case 'Enter':\n        case ' ':\n          e.preventDefault();\n          e.stopPropagation();\n          state.toggle('first');\n          break;\n\n        case 'ArrowUp':\n          e.preventDefault();\n          e.stopPropagation();\n          state.toggle('last');\n          break;\n      }\n    }\n  };\n\n  return {\n    menuTriggerProps: _babelRuntimeHelpersEsmExtends({}, triggerProps, {\n      id: menuTriggerId,\n      onPressStart: function onPressStart(e) {\n        if (e.pointerType !== 'touch' && e.pointerType !== 'keyboard') {\n          state.toggle(e.pointerType === 'virtual' ? 'first' : null);\n        }\n      },\n      onPress: function onPress(e) {\n        if (e.pointerType === 'touch') {\n          state.toggle();\n        }\n      },\n      onKeyDown: onKeyDown\n    }),\n    menuProps: _babelRuntimeHelpersEsmExtends({}, overlayProps, {\n      'aria-labelledby': menuTriggerId\n    })\n  };\n}\nexport function useMenu(props, state, ref) {\n  var _props$shouldFocusWra = props.shouldFocusWrap,\n      shouldFocusWrap = _props$shouldFocusWra === void 0 ? true : _props$shouldFocusWra,\n      otherProps = _babelRuntimeHelpersEsmObjectWithoutPropertiesLoose(props, [\"shouldFocusWrap\"]);\n\n  if (!props['aria-label'] && !props['aria-labelledby']) {\n    console.warn('An aria-label or aria-labelledby prop is required for accessibility.');\n  }\n\n  var domProps = filterDOMProps(props, {\n    labelable: true\n  });\n\n  var _useSelectableList = useSelectableList(_babelRuntimeHelpersEsmExtends({}, otherProps, {\n    ref: ref,\n    selectionManager: state.selectionManager,\n    collection: state.collection,\n    disabledKeys: state.disabledKeys,\n    shouldFocusWrap: shouldFocusWrap\n  })),\n      listProps = _useSelectableList.listProps;\n\n  return {\n    menuProps: mergeProps(domProps, _babelRuntimeHelpersEsmExtends({\n      role: 'menu'\n    }, listProps))\n  };\n}\nexport function useMenuItem(props, state, ref) {\n  var isSelected = props.isSelected,\n      isDisabled = props.isDisabled,\n      key = props.key,\n      onClose = props.onClose,\n      closeOnSelect = props.closeOnSelect,\n      isVirtualized = props.isVirtualized,\n      onAction = props.onAction;\n  var role = 'menuitem';\n\n  if (state.selectionManager.selectionMode === 'single') {\n    role = 'menuitemradio';\n  } else if (state.selectionManager.selectionMode === 'multiple') {\n    role = 'menuitemcheckbox';\n  }\n\n  var labelId = useSlotId();\n  var descriptionId = useSlotId();\n  var keyboardId = useSlotId();\n  var ariaProps = {\n    'aria-disabled': isDisabled,\n    role: role,\n    'aria-label': props['aria-label'],\n    'aria-labelledby': labelId,\n    'aria-describedby': [descriptionId, keyboardId].filter(Boolean).join(' ') || undefined\n  };\n\n  if (state.selectionManager.selectionMode !== 'none') {\n    ariaProps['aria-checked'] = isSelected;\n  }\n\n  if (isVirtualized) {\n    ariaProps['aria-posinset'] = state.collection.getItem(key).index;\n    ariaProps['aria-setsize'] = getItemCount(state.collection);\n  }\n\n  var onKeyDown = function onKeyDown(e) {\n    if (e.repeat) {\n      return;\n    }\n\n    switch (e.key) {\n      case ' ':\n        if (!isDisabled && state.selectionManager.selectionMode === 'none' && closeOnSelect !== false && onClose) {\n          onClose();\n        }\n\n        break;\n\n      case 'Enter':\n        if (!isDisabled && closeOnSelect !== false && onClose) {\n          onClose();\n        }\n\n        break;\n    }\n  };\n\n  var onPressStart = function onPressStart(e) {\n    if (e.pointerType === 'keyboard' && onAction) {\n      onAction(key);\n    }\n  };\n\n  var onPressUp = function onPressUp(e) {\n    if (e.pointerType !== 'keyboard') {\n      if (onAction) {\n        onAction(key);\n      }\n\n      if (onClose && (closeOnSelect != null ? closeOnSelect : state.selectionManager.selectionMode !== 'multiple')) {\n        onClose();\n      }\n    }\n  };\n\n  var _useSelectableItem = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key: key,\n    ref: ref,\n    shouldSelectOnPressUp: true\n  }),\n      itemProps = _useSelectableItem.itemProps;\n\n  var _usePress = usePress(mergeProps({\n    onPressStart: onPressStart,\n    onPressUp: onPressUp,\n    onKeyDown: onKeyDown,\n    isDisabled: isDisabled\n  }, itemProps)),\n      pressProps = _usePress.pressProps;\n\n  var _useHover = useHover({\n    isDisabled: isDisabled,\n    onHoverStart: function onHoverStart() {\n      if (!isFocusVisible()) {\n        state.selectionManager.setFocused(true);\n        state.selectionManager.setFocusedKey(key);\n      }\n    }\n  }),\n      hoverProps = _useHover.hoverProps;\n\n  return {\n    menuItemProps: _babelRuntimeHelpersEsmExtends({}, ariaProps, mergeProps(pressProps, hoverProps)),\n    labelProps: {\n      id: labelId\n    },\n    descriptionProps: {\n      id: descriptionId\n    },\n    keyboardShortcutProps: {\n      id: keyboardId\n    }\n  };\n}\nexport function useMenuSection(props) {\n  var heading = props.heading,\n      ariaLabel = props['aria-label'];\n  var headingId = useId();\n  return {\n    itemProps: {\n      role: 'presentation'\n    },\n    headingProps: heading ? {\n      id: headingId,\n      'aria-hidden': true\n    } : {},\n    groupProps: {\n      role: 'group',\n      'aria-label': ariaLabel,\n      'aria-labelledby': heading ? headingId : undefined\n    }\n  };\n}","map":{"version":3,"sources":["packages/@react-aria/menu/src/useMenuTrigger.ts","packages/@react-aria/menu/src/useMenu.ts","packages/@react-aria/menu/src/useMenuItem.ts","packages/@react-aria/menu/src/useMenuSection.ts"],"names":["type","isDisabled","menuTriggerId","useId","overlayProps","useOverlayTrigger","onKeyDown","e","ref","state","menuTriggerProps","id","onPressStart","onPress","menuProps","shouldFocusWrap","props","console","domProps","filterDOMProps","labelable","listProps","useSelectableList","selectionManager","collection","disabledKeys","mergeProps","role","onAction","labelId","useSlotId","descriptionId","keyboardId","ariaProps","undefined","getItemCount","closeOnSelect","onClose","onPressUp","itemProps","useSelectableItem","key","shouldSelectOnPressUp","pressProps","usePress","hoverProps","useHover","onHoverStart","isFocusVisible","menuItemProps","labelProps","descriptionProps","keyboardShortcutProps","ariaLabel","headingId","headingProps","heading","groupProps"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaButtonProps} from '@react-types/button';\nimport {HTMLAttributes, RefObject} from 'react';\nimport {MenuTriggerState} from '@react-stately/menu';\nimport {useId} from '@react-aria/utils';\nimport {useOverlayTrigger} from '@react-aria/overlays';\n\ninterface MenuTriggerAriaProps {\n  /** The type of menu that the menu trigger opens. */\n  type?: 'menu' | 'listbox',\n  /** Whether menu trigger is disabled. */\n  isDisabled?: boolean\n}\n\ninterface MenuTriggerAria {\n  /** Props for the menu trigger element. */\n  menuTriggerProps: AriaButtonProps,\n\n  /** Props for the menu. */\n  menuProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a menu trigger.\n * @param props - Props for the menu trigger.\n * @param state - State for the menu trigger.\n */\nexport function useMenuTrigger(props: MenuTriggerAriaProps, state: MenuTriggerState, ref: RefObject<HTMLElement>): MenuTriggerAria {\n  let {\n    type = 'menu' as MenuTriggerAriaProps['type'],\n    isDisabled\n  } = props;\n\n  let menuTriggerId = useId();\n  let {triggerProps, overlayProps} = useOverlayTrigger({type}, state, ref);\n\n  let onKeyDown = (e) => {\n    if ((typeof e.isDefaultPrevented === 'function' && e.isDefaultPrevented()) || e.defaultPrevented || isDisabled) {\n      return;\n    }\n\n    if (ref && ref.current) {\n      switch (e.key) {\n        case 'ArrowDown':\n        case 'Enter':\n        case ' ':\n          e.preventDefault();\n          e.stopPropagation();\n          state.toggle('first');\n          break;\n        case 'ArrowUp':\n          e.preventDefault();\n          e.stopPropagation();\n          state.toggle('last');\n          break;\n      }\n    }\n  };\n\n  return {\n    menuTriggerProps: {\n      ...triggerProps,\n      id: menuTriggerId,\n      onPressStart(e) {\n        // For consistency with native, open the menu on mouse/key down, but touch up.\n        if (e.pointerType !== 'touch' && e.pointerType !== 'keyboard') {\n          // If opened with a screen reader, auto focus the first item.\n          // Otherwise, the menu itself will be focused.\n          state.toggle(e.pointerType === 'virtual' ? 'first' : null);\n        }\n      },\n      onPress(e) {\n        if (e.pointerType === 'touch') {\n          state.toggle();\n        }\n      },\n      onKeyDown\n    },\n    menuProps: {\n      ...overlayProps,\n      'aria-labelledby': menuTriggerId\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaMenuProps} from '@react-types/menu';\nimport {filterDOMProps, mergeProps} from '@react-aria/utils';\nimport {HTMLAttributes, RefObject} from 'react';\nimport {KeyboardDelegate} from '@react-types/shared';\nimport {TreeState} from '@react-stately/tree';\nimport {useSelectableList} from '@react-aria/selection';\n\ninterface MenuAria {\n  /** Props for the menu element. */\n  menuProps: HTMLAttributes<HTMLElement>\n}\n\ninterface AriaMenuOptions<T> extends AriaMenuProps<T> {\n  /** Whether the menu uses virtual scrolling. */\n  isVirtualized?: boolean,\n\n  /**\n   * An optional keyboard delegate implementation for type to select,\n   * to override the default.\n   */\n  keyboardDelegate?: KeyboardDelegate\n}\n\n/**\n * Provides the behavior and accessibility implementation for a menu component.\n * A menu displays a list of actions or options that a user can choose.\n * @param props - Props for the menu.\n * @param state - State for the menu, as returned by `useListState`.\n */\nexport function useMenu<T>(props: AriaMenuOptions<T>, state: TreeState<T>, ref: RefObject<HTMLElement>): MenuAria {\n  let {\n    shouldFocusWrap = true,\n    ...otherProps\n  } = props;\n\n  if (!props['aria-label'] && !props['aria-labelledby']) {\n    console.warn('An aria-label or aria-labelledby prop is required for accessibility.');\n  }\n\n  let domProps = filterDOMProps(props, {labelable: true});\n  let {listProps} = useSelectableList({\n    ...otherProps,\n    ref,\n    selectionManager: state.selectionManager,\n    collection: state.collection,\n    disabledKeys: state.disabledKeys,\n    shouldFocusWrap\n  });\n\n  return {\n    menuProps: mergeProps(domProps, {\n      role: 'menu',\n      ...listProps\n    })\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getItemCount} from '@react-stately/collections';\nimport {HTMLAttributes, Key, RefObject} from 'react';\nimport {isFocusVisible, useHover, usePress} from '@react-aria/interactions';\nimport {mergeProps, useSlotId} from '@react-aria/utils';\nimport {PressEvent} from '@react-types/shared';\nimport {TreeState} from '@react-stately/tree';\nimport {useSelectableItem} from '@react-aria/selection';\n\ninterface MenuItemAria {\n  /** Props for the menu item element. */\n  menuItemProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the main text element inside the menu item. */\n  labelProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the description text element inside the menu item, if any. */\n  descriptionProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the keyboard shortcut text element inside the item, if any. */\n  keyboardShortcutProps: HTMLAttributes<HTMLElement>\n}\n\ninterface AriaMenuItemProps {\n  /** Whether the menu item is disabled. */\n  isDisabled?: boolean,\n\n  /** Whether the menu item is selected. */\n  isSelected?: boolean,\n\n  /** A screen reader only label for the menu item. */\n  'aria-label'?: string,\n\n  /** The unique key for the menu item. */\n  key?: Key,\n\n  /** Handler that is called when the menu should close after selecting an item. */\n  onClose?: () => void,\n\n  /**\n   * Whether the menu should close when the menu item is selected.\n   * @default true\n   */\n  closeOnSelect?: boolean,\n\n  /** Whether the menu item is contained in a virtual scrolling menu. */\n  isVirtualized?: boolean,\n\n  /** Handler that is called when the user activates the item. */\n  onAction?: (key: Key) => void\n}\n\n/**\n * Provides the behavior and accessibility implementation for an item in a menu.\n * See `useMenu` for more details about menus.\n * @param props - Props for the item.\n * @param state - State for the menu, as returned by `useTreeState`.\n */\nexport function useMenuItem<T>(props: AriaMenuItemProps, state: TreeState<T>, ref: RefObject<HTMLElement>): MenuItemAria {\n  let {\n    isSelected,\n    isDisabled,\n    key,\n    onClose,\n    closeOnSelect,\n    isVirtualized,\n    onAction\n  } = props;\n\n  let role = 'menuitem';\n  if (state.selectionManager.selectionMode === 'single') {\n    role = 'menuitemradio';\n  } else if (state.selectionManager.selectionMode === 'multiple') {\n    role = 'menuitemcheckbox';\n  }\n\n  let labelId = useSlotId();\n  let descriptionId = useSlotId();\n  let keyboardId = useSlotId();\n\n  let ariaProps = {\n    'aria-disabled': isDisabled,\n    role,\n    'aria-label': props['aria-label'],\n    'aria-labelledby': labelId,\n    'aria-describedby': [descriptionId, keyboardId].filter(Boolean).join(' ') || undefined\n  };\n\n  if (state.selectionManager.selectionMode !== 'none') {\n    ariaProps['aria-checked'] = isSelected;\n  }\n\n  if (isVirtualized) {\n    ariaProps['aria-posinset'] = state.collection.getItem(key).index;\n    ariaProps['aria-setsize'] = getItemCount(state.collection);\n  }\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Ignore repeating events, which may have started on the menu trigger before moving\n    // focus to the menu item. We want to wait for a second complete key press sequence.\n    if (e.repeat) {\n      return;\n    }\n\n    switch (e.key) {\n      case ' ':\n        if (!isDisabled && state.selectionManager.selectionMode === 'none' && closeOnSelect !== false && onClose) {\n          onClose();\n        }\n        break;\n      case 'Enter':\n        // The Enter key should always close on select, except if overridden.\n        if (!isDisabled && closeOnSelect !== false && onClose) {\n          onClose();\n        }\n        break;\n    }\n  };\n\n  let onPressStart = (e: PressEvent) => {\n    if (e.pointerType === 'keyboard' && onAction) {\n      onAction(key);\n    }\n  };\n\n  let onPressUp = (e: PressEvent) => {\n    if (e.pointerType !== 'keyboard') {\n      if (onAction) {\n        onAction(key);\n      }\n\n      // Pressing a menu item should close by default in single selection mode but not multiple\n      // selection mode, except if overridden by the closeOnSelect prop.\n      if (onClose && (closeOnSelect ?? state.selectionManager.selectionMode !== 'multiple')) {\n        onClose();\n      }\n    }\n  };\n\n  let {itemProps} = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key,\n    ref,\n    shouldSelectOnPressUp: true\n  });\n\n  let {pressProps} = usePress(mergeProps({onPressStart, onPressUp, onKeyDown, isDisabled}, itemProps));\n  let {hoverProps} = useHover({\n    isDisabled,\n    onHoverStart() {\n      if (!isFocusVisible()) {\n        state.selectionManager.setFocused(true);\n        state.selectionManager.setFocusedKey(key);\n      }\n    }\n  });\n\n  return {\n    menuItemProps: {\n      ...ariaProps,\n      ...mergeProps(pressProps, hoverProps)\n    },\n    labelProps: {\n      id: labelId\n    },\n    descriptionProps: {\n      id: descriptionId\n    },\n    keyboardShortcutProps: {\n      id: keyboardId\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {HTMLAttributes, ReactNode} from 'react';\nimport {useId} from '@react-aria/utils';\n\ninterface AriaMenuSectionProps {\n  /** The heading for the section. */\n  heading?: ReactNode,\n  /** An accessibility label for the section. Required if `heading` is not present. */\n  'aria-label'?: string\n}\n\ninterface MenuSectionAria {\n  /** Props for the wrapper list item. */\n  itemProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the heading element, if any. */\n  headingProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the group element. */\n  groupProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a section in a menu.\n * See `useMenu` for more details about menus.\n * @param props - Props for the section.\n */\nexport function useMenuSection(props: AriaMenuSectionProps): MenuSectionAria {\n  let {heading, 'aria-label': ariaLabel} = props;\n  let headingId = useId();\n\n  return {\n    itemProps: {\n      role: 'presentation'\n    },\n    headingProps: heading ? {\n      // Techincally, menus cannot contain headings according to ARIA.\n      // We hide the heading from assistive technology, and only use it\n      // as a label for the nested group.\n      id: headingId,\n      'aria-hidden': true\n    } : {},\n    groupProps: {\n      role: 'group',\n      'aria-label': ariaLabel,\n      'aria-labelledby': heading ? headingId : undefined\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}