{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/wrapNativeSuper\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { useControlledState } from \"@react-stately/utils\";\nimport { useMemo, useRef, useState } from \"react\";\n\nvar $c91e86e24f2dc9a2182dcc2674c58c$export$Selection = function (_Set) {\n  _inherits($c91e86e24f2dc9a2182dcc2674c58c$export$Selection, _Set);\n\n  var _super = _createSuper($c91e86e24f2dc9a2182dcc2674c58c$export$Selection);\n\n  function $c91e86e24f2dc9a2182dcc2674c58c$export$Selection(keys, anchorKey, currentKey) {\n    var _this;\n\n    _classCallCheck(this, $c91e86e24f2dc9a2182dcc2674c58c$export$Selection);\n\n    _this = _super.call(this, keys);\n    _this.anchorKey = void 0;\n    _this.currentKey = void 0;\n\n    if (keys instanceof $c91e86e24f2dc9a2182dcc2674c58c$export$Selection) {\n      _this.anchorKey = anchorKey || keys.anchorKey;\n      _this.currentKey = currentKey || keys.currentKey;\n    } else {\n      _this.anchorKey = anchorKey;\n      _this.currentKey = currentKey;\n    }\n\n    return _this;\n  }\n\n  return $c91e86e24f2dc9a2182dcc2674c58c$export$Selection;\n}(_wrapNativeSuper(Set));\n\nexport function useMultipleSelectionState(props) {\n  var _props$selectionMode = props.selectionMode,\n      selectionMode = _props$selectionMode === void 0 ? 'none' : _props$selectionMode,\n      disallowEmptySelection = props.disallowEmptySelection;\n  var isFocusedRef = useRef(false);\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      _setFocused = _useState2[1];\n\n  var focusedKeyRef = useRef(null);\n  var childFocusStrategyRef = useRef(null);\n\n  var _useState3 = useState(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      _setFocusedKey = _useState4[1];\n\n  var selectedKeysProp = useMemo(function () {\n    return $c86d35e876e048ac11515eee40c7$var$convertSelection(props.selectedKeys);\n  }, [props.selectedKeys]);\n  var defaultSelectedKeys = useMemo(function () {\n    return $c86d35e876e048ac11515eee40c7$var$convertSelection(props.defaultSelectedKeys, new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection());\n  }, [props.defaultSelectedKeys]);\n\n  var _useControlledState = useControlledState(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange),\n      _useControlledState2 = _slicedToArray(_useControlledState, 2),\n      selectedKeys = _useControlledState2[0],\n      setSelectedKeys = _useControlledState2[1];\n\n  var disabledKeysProp = useMemo(function () {\n    return props.disabledKeys ? new Set(props.disabledKeys) : new Set();\n  }, [props.disabledKeys]);\n  return {\n    selectionMode: selectionMode,\n    disallowEmptySelection: disallowEmptySelection,\n\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n\n    setFocused: function setFocused(f) {\n      isFocusedRef.current = f;\n\n      _setFocused(f);\n    },\n\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n\n    setFocusedKey: function setFocusedKey(k, childFocusStrategy) {\n      if (childFocusStrategy === void 0) {\n        childFocusStrategy = 'first';\n      }\n\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n\n      _setFocusedKey(k);\n    },\n    selectedKeys: selectedKeys,\n    setSelectedKeys: setSelectedKeys,\n    disabledKeys: disabledKeysProp\n  };\n}\n\nfunction $c86d35e876e048ac11515eee40c7$var$convertSelection(selection, defaultValue) {\n  if (!selection) {\n    return defaultValue;\n  }\n\n  return selection === 'all' ? 'all' : new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection(selection);\n}\n\nexport var SelectionManager = function () {\n  function SelectionManager(collection, state, options) {\n    _classCallCheck(this, SelectionManager);\n\n    var _options$allowsCellSe;\n\n    this.collection = void 0;\n    this.state = void 0;\n    this.allowsCellSelection = void 0;\n    this._isSelectAll = void 0;\n    this.collection = collection;\n    this.state = state;\n    this.allowsCellSelection = (_options$allowsCellSe = options == null ? void 0 : options.allowsCellSelection) != null ? _options$allowsCellSe : false;\n    this._isSelectAll = null;\n  }\n\n  _createClass(SelectionManager, [{\n    key: \"selectionMode\",\n    get: function get() {\n      return this.state.selectionMode;\n    }\n  }, {\n    key: \"disallowEmptySelection\",\n    get: function get() {\n      return this.state.disallowEmptySelection;\n    }\n  }, {\n    key: \"isFocused\",\n    get: function get() {\n      return this.state.isFocused;\n    }\n  }, {\n    key: \"setFocused\",\n    value: function setFocused(isFocused) {\n      this.state.setFocused(isFocused);\n    }\n  }, {\n    key: \"focusedKey\",\n    get: function get() {\n      return this.state.focusedKey;\n    }\n  }, {\n    key: \"childFocusStrategy\",\n    get: function get() {\n      return this.state.childFocusStrategy;\n    }\n  }, {\n    key: \"setFocusedKey\",\n    value: function setFocusedKey(key, childFocusStrategy) {\n      this.state.setFocusedKey(key, childFocusStrategy);\n    }\n  }, {\n    key: \"selectedKeys\",\n    get: function get() {\n      return this.state.selectedKeys === 'all' ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n    }\n  }, {\n    key: \"rawSelection\",\n    get: function get() {\n      return this.state.selectedKeys;\n    }\n  }, {\n    key: \"isSelected\",\n    value: function isSelected(key) {\n      if (this.state.selectionMode === 'none') {\n        return false;\n      }\n\n      key = this.getKey(key);\n      return this.state.selectedKeys === 'all' ? !this.state.disabledKeys.has(key) : this.state.selectedKeys.has(key);\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n    }\n  }, {\n    key: \"isSelectAll\",\n    get: function get() {\n      if (this.isEmpty) {\n        return false;\n      }\n\n      if (this.state.selectedKeys === 'all') {\n        return true;\n      }\n\n      if (this._isSelectAll != null) {\n        return this._isSelectAll;\n      }\n\n      var allKeys = this.getSelectAllKeys();\n      var selectedKeys = this.state.selectedKeys;\n      this._isSelectAll = allKeys.every(function (k) {\n        return selectedKeys.has(k);\n      });\n      return this._isSelectAll;\n    }\n  }, {\n    key: \"firstSelectedKey\",\n    get: function get() {\n      var _first;\n\n      var first = null;\n\n      for (var _iterator = _createForOfIteratorHelperLoose(this.state.selectedKeys), _step; !(_step = _iterator()).done;) {\n        var key = _step.value;\n        var item = this.collection.getItem(key);\n\n        if (!first || (item == null ? void 0 : item.index) < first.index) {\n          first = item;\n        }\n      }\n\n      return (_first = first) == null ? void 0 : _first.key;\n    }\n  }, {\n    key: \"lastSelectedKey\",\n    get: function get() {\n      var _last;\n\n      var last = null;\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(this.state.selectedKeys), _step2; !(_step2 = _iterator2()).done;) {\n        var key = _step2.value;\n        var item = this.collection.getItem(key);\n\n        if (!last || (item == null ? void 0 : item.index) > last.index) {\n          last = item;\n        }\n      }\n\n      return (_last = last) == null ? void 0 : _last.key;\n    }\n  }, {\n    key: \"extendSelection\",\n    value: function extendSelection(toKey) {\n      toKey = this.getKey(toKey);\n      var selection;\n\n      if (this.state.selectedKeys === 'all') {\n        selection = new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection([toKey], toKey, toKey);\n      } else {\n        var selectedKeys = this.state.selectedKeys;\n        var anchorKey = selectedKeys.anchorKey || toKey;\n        selection = new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection(selectedKeys, anchorKey, toKey);\n\n        for (var _iterator3 = _createForOfIteratorHelperLoose(this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)), _step3; !(_step3 = _iterator3()).done;) {\n          var key = _step3.value;\n          selection.delete(key);\n        }\n\n        for (var _iterator4 = _createForOfIteratorHelperLoose(this.getKeyRange(toKey, anchorKey)), _step4; !(_step4 = _iterator4()).done;) {\n          var _key = _step4.value;\n\n          if (!this.state.disabledKeys.has(_key)) {\n            selection.add(_key);\n          }\n        }\n      }\n\n      this.state.setSelectedKeys(selection);\n    }\n  }, {\n    key: \"getKeyRange\",\n    value: function getKeyRange(from, to) {\n      var fromItem = this.collection.getItem(from);\n      var toItem = this.collection.getItem(to);\n\n      if (fromItem && toItem) {\n        if (fromItem.index <= toItem.index) {\n          return this.getKeyRangeInternal(from, to);\n        }\n\n        return this.getKeyRangeInternal(to, from);\n      }\n\n      return [];\n    }\n  }, {\n    key: \"getKeyRangeInternal\",\n    value: function getKeyRangeInternal(from, to) {\n      var keys = [];\n      var key = from;\n\n      while (key) {\n        var item = this.collection.getItem(key);\n\n        if (item && item.type === 'item' || item.type === 'cell' && this.allowsCellSelection) {\n          keys.push(key);\n        }\n\n        if (key === to) {\n          return keys;\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n\n      return [];\n    }\n  }, {\n    key: \"getKey\",\n    value: function getKey(key) {\n      var item = this.collection.getItem(key);\n\n      if (!item) {\n        return key;\n      }\n\n      if (item.type === 'cell' && this.allowsCellSelection) {\n        return key;\n      }\n\n      while (item.type !== 'item' && item.parentKey) {\n        item = this.collection.getItem(item.parentKey);\n      }\n\n      if (!item || item.type !== 'item') {\n        return null;\n      }\n\n      return item.key;\n    }\n  }, {\n    key: \"toggleSelection\",\n    value: function toggleSelection(key) {\n      key = this.getKey(key);\n\n      if (key == null) {\n        return;\n      }\n\n      var keys = new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n\n      if (keys.has(key)) {\n        keys.delete(key);\n      } else {\n        keys.add(key);\n        keys.anchorKey = key;\n        keys.currentKey = key;\n      }\n\n      if (this.disallowEmptySelection && keys.size === 0) {\n        return;\n      }\n\n      this.state.setSelectedKeys(keys);\n    }\n  }, {\n    key: \"replaceSelection\",\n    value: function replaceSelection(key) {\n      key = this.getKey(key);\n\n      if (key == null) {\n        return;\n      }\n\n      this.state.setSelectedKeys(new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection([key], key, key));\n    }\n  }, {\n    key: \"setSelectedKeys\",\n    value: function setSelectedKeys(keys) {\n      if (this.selectionMode === 'none') {\n        return;\n      }\n\n      var selection = new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection();\n\n      for (var _iterator5 = _createForOfIteratorHelperLoose(keys), _step5; !(_step5 = _iterator5()).done;) {\n        var key = _step5.value;\n        key = this.getKey(key);\n\n        if (key != null) {\n          selection.add(key);\n\n          if (this.selectionMode === 'single') {\n            break;\n          }\n        }\n      }\n\n      this.state.setSelectedKeys(selection);\n    }\n  }, {\n    key: \"getSelectAllKeys\",\n    value: function getSelectAllKeys() {\n      var _this2 = this;\n\n      var keys = [];\n\n      var addKeys = function addKeys(key) {\n        while (key) {\n          if (!_this2.state.disabledKeys.has(key)) {\n            var item = _this2.collection.getItem(key);\n\n            if (item.type === 'item') {\n              keys.push(key);\n            }\n\n            if (item.hasChildNodes && (_this2.allowsCellSelection || item.type !== 'item')) {\n              addKeys(_toConsumableArray(item.childNodes)[0].key);\n            }\n          }\n\n          key = _this2.collection.getKeyAfter(key);\n        }\n      };\n\n      addKeys(this.collection.getFirstKey());\n      return keys;\n    }\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      if (this.selectionMode === 'multiple') {\n        this.state.setSelectedKeys('all');\n      }\n    }\n  }, {\n    key: \"clearSelection\",\n    value: function clearSelection() {\n      if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {\n        this.state.setSelectedKeys(new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection());\n      }\n    }\n  }, {\n    key: \"toggleSelectAll\",\n    value: function toggleSelectAll() {\n      if (this.isSelectAll) {\n        this.clearSelection();\n      } else {\n        this.selectAll();\n      }\n    }\n  }, {\n    key: \"select\",\n    value: function select(key, e) {\n      if (this.selectionMode === 'none') {\n        return;\n      }\n\n      if (this.selectionMode === 'single') {\n        if (this.isSelected(key) && !this.disallowEmptySelection) {\n          this.toggleSelection(key);\n        } else {\n          this.replaceSelection(key);\n        }\n      } else if (e && e.shiftKey) {\n        this.extendSelection(key);\n      } else {\n        this.toggleSelection(key);\n      }\n    }\n  }, {\n    key: \"isSelectionEqual\",\n    value: function isSelectionEqual(selection) {\n      if (selection === this.state.selectedKeys) {\n        return true;\n      }\n\n      var selectedKeys = this.selectedKeys;\n\n      if (selection.size !== selectedKeys.size) {\n        return false;\n      }\n\n      for (var _iterator6 = _createForOfIteratorHelperLoose(selection), _step6; !(_step6 = _iterator6()).done;) {\n        var key = _step6.value;\n\n        if (!selectedKeys.has(key)) {\n          return false;\n        }\n      }\n\n      for (var _iterator7 = _createForOfIteratorHelperLoose(selectedKeys), _step7; !(_step7 = _iterator7()).done;) {\n        var _key2 = _step7.value;\n\n        if (!selection.has(_key2)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return SelectionManager;\n}();","map":{"version":3,"sources":["packages/@react-stately/selection/src/Selection.ts","packages/@react-stately/selection/src/useMultipleSelectionState.ts","packages/@react-stately/selection/src/SelectionManager.ts"],"names":["anchorKey","currentKey","constructor","keys","selectionMode","disallowEmptySelection","isFocusedRef","useRef","useState","focusedKeyRef","childFocusStrategyRef","selectedKeysProp","useMemo","convertSelection","props","defaultSelectedKeys","useControlledState","disabledKeysProp","setFocused","setFocusedKey","childFocusStrategy","selectedKeys","setSelectedKeys","disabledKeys","selection","collection","state","allowsCellSelection","_isSelectAll","options","isSelected","key","allKeys","k","first","item","last","extendSelection","toKey","fromItem","toItem","toggleSelection","replaceSelection","addKeys","selectAll","clearSelection","toggleSelectAll","select","e","isSelectionEqual"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\n\n/**\n * A Selection is a special Set containing Keys, which also has an anchor\n * and current selected key for use when range selecting.\n */\nexport class Selection extends Set<Key> {\n  anchorKey: Key;\n  currentKey: Key;\n\n  constructor(keys?: Iterable<Key> | Selection, anchorKey?: Key, currentKey?: Key) {\n    super(keys);\n    if (keys instanceof Selection) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useRef, useState} from 'react';\nimport {MultipleSelection, SelectionMode} from '@react-types/shared';\nimport {MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\nimport {useControlledState} from '@react-stately/utils';\n\n/**\n * Manages state for multiple selection and focus in a collection.\n */\nexport function useMultipleSelectionState(props: MultipleSelection): MultipleSelectionState {\n  let {\n    selectionMode = 'none' as SelectionMode,\n    disallowEmptySelection\n  } = props;\n\n  // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n  let isFocusedRef = useRef(false);\n  let [, setFocused] = useState(false);\n  let focusedKeyRef = useRef(null);\n  let childFocusStrategyRef = useRef(null);\n  let [, setFocusedKey] = useState(null);\n  let selectedKeysProp = useMemo(() => convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = useMemo(() => convertSelection(props.defaultSelectedKeys, new Selection()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = useControlledState(\n    selectedKeysProp,\n    defaultSelectedKeys,\n    props.onSelectionChange\n  );\n  let disabledKeysProp = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n\n  return {\n    selectionMode,\n    disallowEmptySelection,\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n    setFocusedKey(k, childFocusStrategy = 'first') {\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n    selectedKeys,\n    setSelectedKeys,\n    disabledKeys: disabledKeysProp\n  };\n}\n\nfunction convertSelection(selection: 'all' | Iterable<Key>, defaultValue?: Selection): 'all' | Selection {\n  if (!selection) {\n    return defaultValue;\n  }\n\n  return selection === 'all'\n    ? 'all'\n    : new Selection(selection);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, FocusStrategy, Selection as ISelection, Node, PressEvent, SelectionMode} from '@react-types/shared';\nimport {Key} from 'react';\nimport {MultipleSelectionManager, MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\n\ninterface SelectionManagerOptions {\n  allowsCellSelection?: boolean\n}\n\n/**\n * An interface for reading and updating multiple selection state.\n */\nexport class SelectionManager implements MultipleSelectionManager {\n  private collection: Collection<Node<unknown>>;\n  private state: MultipleSelectionState;\n  private allowsCellSelection: boolean;\n  private _isSelectAll: boolean;\n\n  constructor(collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions) {\n    this.collection = collection;\n    this.state = state;\n    this.allowsCellSelection = options?.allowsCellSelection ?? false;\n    this._isSelectAll = null;\n  }\n\n  /**\n   * The type of selection that is allowed in the collection.\n   */\n  get selectionMode(): SelectionMode {\n    return this.state.selectionMode;\n  }\n\n  /**\n   * Whether the collection allows empty selection.\n   */\n  get disallowEmptySelection(): boolean {\n    return this.state.disallowEmptySelection;\n  }\n\n  /**\n   * Whether the collection is currently focused.\n   */\n  get isFocused(): boolean {\n    return this.state.isFocused;\n  }\n\n  /**\n   * Sets whether the collection is focused.\n   */\n  setFocused(isFocused: boolean) {\n    this.state.setFocused(isFocused);\n  }\n\n  /**\n   * The current focused key in the collection.\n   */\n  get focusedKey(): Key {\n    return this.state.focusedKey;\n  }\n\n  /** Whether the first or last child of the focused key should receive focus. */\n  get childFocusStrategy(): FocusStrategy {\n    return this.state.childFocusStrategy;\n  }\n\n  /**\n   * Sets the focused key.\n   */\n  setFocusedKey(key: Key, childFocusStrategy?: FocusStrategy) {\n    this.state.setFocusedKey(key, childFocusStrategy);\n  }\n\n  /**\n   * The currently selected keys in the collection.\n   */\n  get selectedKeys(): Set<Key> {\n    return this.state.selectedKeys === 'all'\n      ? new Set(this.getSelectAllKeys())\n      : this.state.selectedKeys;\n  }\n\n  /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */\n  get rawSelection(): ISelection {\n    return this.state.selectedKeys;\n  }\n\n  /**\n   * Returns whether a key is selected.\n   */\n  isSelected(key: Key) {\n    if (this.state.selectionMode === 'none') {\n      return false;\n    }\n\n    key = this.getKey(key);\n    return this.state.selectedKeys === 'all'\n      ? !this.state.disabledKeys.has(key)\n      : this.state.selectedKeys.has(key);\n  }\n\n  /**\n   * Whether the selection is empty.\n   */\n  get isEmpty(): boolean {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n\n  /**\n   * Whether all items in the collection are selected.\n   */\n  get isSelectAll(): boolean {\n    if (this.isEmpty) {\n      return false;\n    }\n\n    if (this.state.selectedKeys === 'all') {\n      return true;\n    }\n\n    if (this._isSelectAll != null) {\n      return this._isSelectAll;\n    }\n\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey(): Key | null {\n    let first: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || item?.index < first.index) {\n        first = item;\n      }\n    }\n\n    return first?.key;\n  }\n\n  get lastSelectedKey(): Key | null {\n    let last: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || item?.index > last.index) {\n        last = item;\n      }\n    }\n\n    return last?.key;\n  }\n\n  /**\n   * Extends the selection to the given key.\n   */\n  extendSelection(toKey: Key) {\n    toKey = this.getKey(toKey);\n\n    let selection: Selection;\n\n    // Only select the one key if coming from a select all.\n    if (this.state.selectedKeys === 'all') {\n      selection = new Selection([toKey], toKey, toKey);\n    } else {\n      let selectedKeys = this.state.selectedKeys as Selection;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new Selection(selectedKeys, anchorKey, toKey);\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) {\n        selection.delete(key);\n      }\n\n      for (let key of this.getKeyRange(toKey, anchorKey)) {\n        if (!this.state.disabledKeys.has(key)) {\n          selection.add(key);\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getKeyRange(from: Key, to: Key) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n    if (fromItem && toItem) {\n      if (fromItem.index <= toItem.index) {\n        return this.getKeyRangeInternal(from, to);\n      }\n\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  private getKeyRangeInternal(from: Key, to: Key) {\n    let keys: Key[] = [];\n    let key = from;\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === 'item' || (item.type === 'cell' && this.allowsCellSelection)) {\n        keys.push(key);\n      }\n\n      if (key === to) {\n        return keys;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  private getKey(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      // ¯\\_(ツ)_/¯\n      return key;\n    }\n\n    // If cell selection is allowed, just return the key.\n    if (item.type === 'cell' && this.allowsCellSelection) {\n      return key;\n    }\n\n    // Find a parent item to select\n    while (item.type !== 'item' && item.parentKey) {\n      item = this.collection.getItem(item.parentKey);\n    }\n\n    if (!item || item.type !== 'item') {\n      return null;\n    }\n\n    return item.key;\n  }\n\n  /**\n   * Toggles whether the given key is selected.\n   */\n  toggleSelection(key: Key) {\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let keys = new Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) {\n      keys.delete(key);\n      // TODO: move anchor to last selected key...\n      // Does `current` need to move here too?\n    } else {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n\n    if (this.disallowEmptySelection && keys.size === 0) {\n      return;\n    }\n\n    this.state.setSelectedKeys(keys);\n  }\n\n  /**\n   * Replaces the selection with only the given key.\n   */\n  replaceSelection(key: Key) {\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    this.state.setSelectedKeys(new Selection([key], key, key));\n  }\n\n  /**\n   * Replaces the selection with the given keys.\n   */\n  setSelectedKeys(keys: Iterable<Key>) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    let selection = new Selection();\n    for (let key of keys) {\n      key = this.getKey(key);\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === 'single') {\n          break;\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getSelectAllKeys() {\n    let keys: Key[] = [];\n    let addKeys = (key: Key) => {\n      while (key) {\n        if (!this.state.disabledKeys.has(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === 'item') {\n            keys.push(key);\n          }\n\n          // Add child keys. If cell selection is allowed, then include item children too.\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) {\n            addKeys([...item.childNodes][0].key);\n          }\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n\n  /**\n   * Selects all items in the collection.\n   */\n  selectAll() {\n    if (this.selectionMode === 'multiple') {\n      this.state.setSelectedKeys('all');\n    }\n  }\n\n  /**\n   * Removes all keys from the selection.\n   */\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {\n      this.state.setSelectedKeys(new Selection());\n    }\n  }\n\n  /**\n   * Toggles between select all and an empty selection.\n   */\n  toggleSelectAll() {\n    if (this.isSelectAll) {\n      this.clearSelection();\n    } else {\n      this.selectAll();\n    }\n  }\n\n  select(key: Key, e?: PressEvent | PointerEvent) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) {\n        this.toggleSelection(key);\n      } else {\n        this.replaceSelection(key);\n      }\n    } else if (e && e.shiftKey) {\n      this.extendSelection(key);\n    } else {\n      this.toggleSelection(key);\n    }\n  }\n\n  /**\n   * Returns whether the current selection is equal to the given selection.\n   */\n  isSelectionEqual(selection: Set<Key>) {\n    if (selection === this.state.selectedKeys) {\n      return true;\n    }\n\n    // Check if the set of keys match.\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) {\n      return false;\n    }\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) {\n        return false;\n      }\n    }\n\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}