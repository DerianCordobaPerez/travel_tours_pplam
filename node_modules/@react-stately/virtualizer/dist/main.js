var _babelRuntimeHelpersExtends = $parcel$interopDefault(require("@babel/runtime/helpers/extends"));

var {
  useLayoutEffect
} = require("@react-aria/utils");

var {
  useCallback,
  useEffect,
  useMemo,
  useState
} = require("react");

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// import {Point} from './Point';
// import { DragTarget, DropTarget } from '@react-types/shared';

/**
 * [CollectionView]{@link CollectionView} supports arbitrary layout objects, which compute what views are visible, and how
 * to position and style them. However, layouts do not create the views themselves directly. Instead,
 * layouts produce lightweight {@link LayoutInfo} objects which describe various properties of a view,
 * such as its position and size. The {@link CollectionView} is then responsible for creating the actual
 * views as needed, based on this layout information.
 *
 * Every layout extends from the {@link Layout} abstract base class. Layouts must implement a minimum of the
 * two methods listed below. All other methods can be optionally overridden to implement custom behavior.
 *
 * @see {@link getVisibleLayoutInfos}
 * @see {@link getLayoutInfo}
 */
class Layout {
  constructor() {
    this.virtualizer = void 0;
  }

  /**
   * Returns whether the layout should invalidate in response to
   * visible rectangle changes. By default, it only invalidates
   * when the collection view's size changes. Return true always
   * to make the layout invalidate while scrolling (e.g. sticky headers).
   */
  shouldInvalidate(newRect, oldRect) {
    // By default, invalidate when the size changes
    return newRect.width !== oldRect.width || newRect.height !== oldRect.height;
  }
  /**
   * This method allows the layout to perform any pre-computation
   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.
   * Called by the collection view before {@link getVisibleLayoutInfos}
   * or {@link getLayoutInfo} are called.
   */


  validate(invalidationContext) {} // eslint-disable-line @typescript-eslint/no-unused-vars

  /**
   * Returns an array of {@link LayoutInfo} objects which are inside the given rectangle.
   * Should be implemented by subclasses.
   * @param rect The rectangle that should contain the returned LayoutInfo objects.
   */


  /**
   * Returns a {@link DragTarget} describing a view at the given point to be dragged.
   * Return `null` to cancel the drag. The default implementation returns the view at the given point.
   * @param point The point at which the drag occurred.
   */
  // getDragTarget(point: Point): DragTarget | null {
  //   let target = this.virtualizer.keyAtPoint(point);
  //   if (!target) {
  //     return null;
  //   }
  //   return {
  //     type: 'item',
  //     key: target
  //   };
  // }

  /**
   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`
   * to reject the drop. The dropped items will be inserted before the resulting target.
   * @param point The point at which the drop occurred.
   */
  // getDropTarget(point: Point): DropTarget | null {
  //   return null;
  // }

  /**
   * Returns the starting attributes for an animated insertion.
   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.
   * The default implementation just returns its input.
   *
   * @param layoutInfo The proposed LayoutInfo for this view.
   */
  getInitialLayoutInfo(layoutInfo) {
    return layoutInfo;
  }
  /**
   * Returns the ending attributes for an animated removal.
   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}
   * to the one returned by this method. The default implementation returns its input.
   *
   * @param layoutInfo The original LayoutInfo for this view.
   */


  getFinalLayoutInfo(layoutInfo) {
    return layoutInfo;
  }

}

exports.Layout = Layout;

/**
 * Instances of this lightweight class are created by {@link Layout} subclasses
 * to represent each view in the {@link CollectionView}. LayoutInfo objects describe
 * various properties of a view, such as its position and size, and style information.
 * The collection view uses this information when creating actual views to display.
 */
class LayoutInfo {
  /**
   * A string representing the view type. Should be `'item'` for item views.
   * Other types are used by supplementary views.
   */

  /**
   * A unique key for this view. For item views, it should match the content key.
   */

  /**
   * The key for a parent layout info, if any.
   */

  /**
   * The rectangle describing the size and position of this view.
   */

  /**
   * Whether the size is estimated. `false` by default.
   */

  /**
   * Whether the layout info sticks to the viewport when scrolling.
   */

  /**
   * The view's opacity. 1 by default.
   */

  /**
   * A CSS transform string to apply to the view. `null` by default.
   */

  /**
   * The z-index of the view. 0 by default.
   */

  /**
   * @param type A string representing the view type. Should be `'item'` for item views.
                            Other types are used by supplementary views.
   * @param key The unique key for this view.
   * @param rect The rectangle describing the size and position of this view.
   */
  constructor(type, key, rect) {
    this.type = void 0;
    this.key = void 0;
    this.parentKey = void 0;
    this.rect = void 0;
    this.estimatedSize = void 0;
    this.isSticky = void 0;
    this.opacity = void 0;
    this.transform = void 0;
    this.zIndex = void 0;
    this.type = type;
    this.key = key;
    this.parentKey = null;
    this.rect = rect;
    this.estimatedSize = false;
    this.isSticky = false;
    this.opacity = 1;
    this.transform = null;
    this.zIndex = 0;
  }
  /**
   * Returns a copy of the LayoutInfo.
   */


  copy() {
    let res = new LayoutInfo(this.type, this.key, this.rect.copy());
    res.estimatedSize = this.estimatedSize;
    res.opacity = this.opacity;
    res.transform = this.transform;
    res.parentKey = this.parentKey;
    res.isSticky = this.isSticky;
    res.zIndex = this.zIndex;
    return res;
  }

}

exports.LayoutInfo = LayoutInfo;

class Point {
  /** The x-coordinate of the point. */

  /** The y-coordinate of the point. */
  constructor(x, y) {
    if (x === void 0) {
      x = 0;
    }

    if (y === void 0) {
      y = 0;
    }

    this.x = void 0;
    this.y = void 0;
    this.x = x;
    this.y = y;
  }
  /**
   * Returns a copy of this point.
   */


  copy() {
    return new Point(this.x, this.y);
  }
  /**
   * Checks if two points are equal.
   */


  equals(point) {
    return this.x === point.x && this.y === point.y;
  }
  /**
   * Returns true if this point is the origin.
   */


  isOrigin() {
    return this.x === 0 && this.y === 0;
  }

}

exports.Point = Point;

/**
 * Represents a rectangle.
 */
class Rect {
  /** The x-coordinate of the rectangle. */

  /** The y-coordinate of the rectangle. */

  /** The width of the rectangle. */

  /** The height of the rectangle. */
  constructor(x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }

    if (y === void 0) {
      y = 0;
    }

    if (width === void 0) {
      width = 0;
    }

    if (height === void 0) {
      height = 0;
    }

    this.x = void 0;
    this.y = void 0;
    this.width = void 0;
    this.height = void 0;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  /**
   * The maximum x-coordinate in the rectangle.
   */


  get maxX() {
    return this.x + this.width;
  }
  /**
   * The maximum y-coordinate in the rectangle.
   */


  get maxY() {
    return this.y + this.height;
  }
  /**
   * The area of the rectangle.
   */


  get area() {
    return this.width * this.height;
  }
  /**
   * The top left corner of the rectangle.
   */


  get topLeft() {
    return new Point(this.x, this.y);
  }
  /**
   * The top right corner of the rectangle.
   */


  get topRight() {
    return new Point(this.maxX, this.y);
  }
  /**
   * The bottom left corner of the rectangle.
   */


  get bottomLeft() {
    return new Point(this.x, this.maxY);
  }
  /**
   * The bottom right corner of the rectangle.
   */


  get bottomRight() {
    return new Point(this.maxX, this.maxY);
  }
  /**
   * Returns whether this rectangle intersects another rectangle.
   * @param rect - The rectangle to check.
   */


  intersects(rect) {
    return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;
  }
  /**
   * Returns whether this rectangle fully contains another rectangle.
   * @param rect - The rectangle to check.
   */


  containsRect(rect) {
    return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;
  }
  /**
   * Returns whether the rectangle contains the given point.
   * @param point - The point to check.
   */


  containsPoint(point) {
    return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;
  }
  /**
   * Returns the first corner of this rectangle (from top to bottom, left to right)
   * that is contained in the given rectangle, or null of the rectangles do not intersect.
   * @param rect - The rectangle to check.
   */


  getCornerInRect(rect) {
    for (let key of ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']) {
      if (rect.containsPoint(this[key])) {
        return key;
      }
    }

    return null;
  }

  equals(rect) {
    return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
  }

  pointEquals(point) {
    return this.x === point.x && this.y === point.y;
  }

  sizeEquals(size) {
    return this.width === size.width && this.height === size.height;
  }
  /**
   * Returns a copy of this rectangle.
   */


  copy() {
    return new Rect(this.x, this.y, this.width, this.height);
  }

}

exports.Rect = Rect;

class Size {
  constructor(width, height) {
    if (width === void 0) {
      width = 0;
    }

    if (height === void 0) {
      height = 0;
    }

    this.width = void 0;
    this.height = void 0;
    this.width = width;
    this.height = height;
  }
  /**
   * Returns a copy of this size.
   */


  copy() {
    return new Size(this.width, this.height);
  }
  /**
   * Returns whether this size is equal to another one.
   */


  equals(other) {
    return this.width === other.width && this.height === other.height;
  }

}

exports.Size = Size;
let $c725352f87b2e3c40c7fcea17c35c2a$var$KEY = 0;
/**
 * [CollectionView]{@link CollectionView} creates instances of the [ReusableView]{@link ReusableView} class to
 * represent views currently being displayed. ReusableViews manage a DOM node, handle
 * applying {@link LayoutInfo} objects to the view, and render content
 * as needed. Subclasses must implement the {@link render} method at a
 * minimum. Other methods can be overridden to customize behavior.
 */

class ReusableView {
  /** The CollectionVirtualizer this view is a part of. */

  /** The LayoutInfo this view is currently representing. */

  /** The content currently being displayed by this view, set by the collection view. */
  constructor(virtualizer) {
    this.virtualizer = void 0;
    this.layoutInfo = void 0;
    this.content = void 0;
    this.rendered = void 0;
    this.viewType = void 0;
    this.key = void 0;
    this.virtualizer = virtualizer;
    this.key = ++$c725352f87b2e3c40c7fcea17c35c2a$var$KEY;
  }
  /**
   * Prepares the view for reuse. Called just before the view is removed from the DOM.
   */


  prepareForReuse() {
    this.content = null;
    this.rendered = null;
    this.layoutInfo = null;
  }

}

exports.ReusableView = ReusableView;
// use high res timer if available
let $c2209bcf49cd606639597eb5ee44c7c1$var$perf = typeof window !== 'undefined' ? window.performance : null; // @ts-ignore

let $c2209bcf49cd606639597eb5ee44c7c1$var$perfNow = $c2209bcf49cd606639597eb5ee44c7c1$var$perf && ($c2209bcf49cd606639597eb5ee44c7c1$var$perf.now || $c2209bcf49cd606639597eb5ee44c7c1$var$perf.webkitNow || $c2209bcf49cd606639597eb5ee44c7c1$var$perf.msNow || $c2209bcf49cd606639597eb5ee44c7c1$var$perf.mozNow);
let $c2209bcf49cd606639597eb5ee44c7c1$var$getTime = $c2209bcf49cd606639597eb5ee44c7c1$var$perfNow ? $c2209bcf49cd606639597eb5ee44c7c1$var$perfNow.bind($c2209bcf49cd606639597eb5ee44c7c1$var$perf) : function () {
  return Date.now ? Date.now() : new Date().getTime();
};
let $c2209bcf49cd606639597eb5ee44c7c1$var$fixTs;

function $c2209bcf49cd606639597eb5ee44c7c1$export$tween(begin, end, duration, ease, fn) {
  let canceled = false;
  let raf_id;
  let promise = new Promise(resolve => {
    let start = $c2209bcf49cd606639597eb5ee44c7c1$var$getTime();
    let diffX = end.x - begin.x;
    let diffY = end.y - begin.y;
    raf_id = requestAnimationFrame(function run(t) {
      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.
      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
      if ($c2209bcf49cd606639597eb5ee44c7c1$var$fixTs == null) {
        $c2209bcf49cd606639597eb5ee44c7c1$var$fixTs = t > 1e12 !== $c2209bcf49cd606639597eb5ee44c7c1$var$getTime() > 1e12;
      }

      if ($c2209bcf49cd606639597eb5ee44c7c1$var$fixTs) {
        t = $c2209bcf49cd606639597eb5ee44c7c1$var$getTime();
      } // check if we're done


      let delta = t - start;

      if (delta > duration) {
        fn(end);
        resolve();
      } else {
        // call frame callback after computing eased time and get the next frame
        let proceed = fn(new Point(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));

        if (proceed !== false && !canceled) {
          raf_id = requestAnimationFrame(run);
        }
      }
    });
  });

  promise.cancel = function () {
    canceled = true;
    cancelAnimationFrame(raf_id);
  };

  return promise;
} // easing functions


function $c2209bcf49cd606639597eb5ee44c7c1$export$easeOut(t) {
  return Math.sin(t * Math.PI / 2);
}

function $eb5c48b3196adea28b2a65513c55f96$export$keyDiff(a, b) {
  let res = new Set();

  for (let key of a.keys()) {
    if (!b.has(key)) {
      res.add(key);
    }
  }

  return res;
}
/**
 * Returns the key difference between two maps. Returns a set of
 * keys to add to and remove from a to make it equal to b.
 * @private
 */


function $eb5c48b3196adea28b2a65513c55f96$export$difference(a, b) {
  let toRemove = $eb5c48b3196adea28b2a65513c55f96$export$keyDiff(a, b);
  let toAdd = $eb5c48b3196adea28b2a65513c55f96$export$keyDiff(b, a);
  let toUpdate = new Set();

  for (let key of a.keys()) {
    if (b.has(key)) {
      toUpdate.add(key);
    }
  }

  return {
    toRemove,
    toAdd,
    toUpdate
  };
}
/**
 * Returns an iterator that yields the items in all of the given iterators.
 * @private
 */


function* $eb5c48b3196adea28b2a65513c55f96$export$concatIterators() {
  for (var _len = arguments.length, iterators = new Array(_len), _key = 0; _key < _len; _key++) {
    iterators[_key] = arguments[_key];
  }

  for (let iterator of iterators) {
    yield* iterator;
  }
}
/**
 * Inverts the keys and values of an object.
 * @private
 */


class $d4638270963df552e2a603f0288c7$var$RollingAverage {
  constructor() {
    this.count = 0;
    this.value = 0;
  }

  addSample(sample) {
    this.count++;
    this.value += (sample - this.value) / this.count;
  }

}

class $d4638270963df552e2a603f0288c7$export$OverscanManager {
  constructor() {
    this.startTime = 0;
    this.averagePerf = new $d4638270963df552e2a603f0288c7$var$RollingAverage();
    this.averageTime = new $d4638270963df552e2a603f0288c7$var$RollingAverage();
    this.velocity = new Point(5, 5);
    this.overscanX = new $d4638270963df552e2a603f0288c7$var$RollingAverage();
    this.overscanY = new $d4638270963df552e2a603f0288c7$var$RollingAverage();
    this.visibleRect = new Rect();
  }

  setVisibleRect(rect) {
    let time = performance.now() - this.startTime;

    if (time < 500) {
      this.averageTime.addSample(time);

      if (rect.x !== this.visibleRect.x && time > 0) {
        this.velocity.x = (rect.x - this.visibleRect.x) / time;
      }

      if (rect.y !== this.visibleRect.y && time > 0) {
        this.velocity.y = (rect.y - this.visibleRect.y) / time;
      }
    }

    this.startTime = performance.now();
    this.visibleRect = rect;
  }

  collectMetrics() {
    let time = performance.now() - this.startTime;

    if (time < 500) {
      this.averagePerf.addSample(time);
    }

    if (this.visibleRect.height > 0) {
      let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));
      this.overscanY.addSample(o);
    }

    if (this.visibleRect.width > 0) {
      let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));
      this.overscanX.addSample(o);
    }
  }

  getOverscannedRect() {
    let overscanned = this.visibleRect.copy();
    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;

    if (this.velocity.y > 0) {
      overscanned.y -= overscanY * 0.2;
      overscanned.height += overscanY + overscanY * 0.2;
    } else {
      overscanned.y -= overscanY;
      overscanned.height += overscanY + overscanY * 0.2;
    }

    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;

    if (this.velocity.x > 0) {
      overscanned.x -= overscanX * 0.2;
      overscanned.width += overscanX + overscanX * 0.2;
    } else {
      overscanned.x -= overscanX;
      overscanned.width += overscanX + overscanX * 0.2;
    }

    return overscanned;
  }

}

class $b8a692491eed0a311c18a0d64051b3$export$Transaction {
  constructor() {
    this.level = 0;
    this.actions = [];
    this.animated = true;
    this.initialMap = new Map();
    this.finalMap = new Map();
    this.initialLayoutInfo = new Map();
    this.finalLayoutInfo = new Map();
    this.removed = new Map();
    this.toRemove = new Map();
  }

}

/**
 * The CollectionView class renders a scrollable collection of data using customizable layouts,
 * and manages animated updates to the data over time. It supports very large collections by
 * only rendering visible views to the DOM, reusing them as you scroll. Collection views can
 * present any type of view, including non-item views such as section headers and footers.
 * Optionally, the {@link EditableCollectionView} subclass can be used to enable user interaction
 * with the collection, including drag and drop, multiple selection, and keyboard interacton.
 *
 * Collection views get their data from a {@link DataSource} object that you provide. Items are
 * grouped into sections by the data source, and the collection view calls its methods to retrieve
 * the data. When data changes, the data source emits change events, and the collection view
 * updates as appropriate, optionally with an animated transition. There is one built-in data source
 * implementation, {@link ArrayDataSource}, which renders content from a 2d array.
 *
 * Collection views use {@link Layout} objects to compute what views should be visible, and how
 * to position and style them. This means that collection views can have their items arranged in
 * a stack, a grid, a circle, or any other layout you can think of. The layout can be changed
 * dynamically at runtime as well, optionally with an animated transition between the layouts.
 *
 * Layouts produce information on what views should appear in the collection view, but do not create
 * the views themselves directly. It is the responsibility of the {@link CollectionViewDelegate} object
 * to create instances of {@link ReusableView} subclasses which render the items into DOM nodes.
 * The delegate determines what type of view to display for each item, and creates instances of
 * views as needed by the collection view. Those views are then reused by the collection view as
 * the user scrolls through the content.
 */
class $c28d52c9ae86344e9273f2344f3d5a45$export$Virtualizer {
  /**
   * The collection view delegate. The delegate is used by the collection view
   * to create and configure views.
   */

  /** The duration of animated layout changes, in milliseconds. Default is 500ms. */

  /**
   * Whether to enable scroll anchoring. This will attempt to restore the scroll position
   * after layout changes outside the viewport. Default is off.
   */

  /** Whether to anchor the scroll position when at the top of the content. Default is off. */

  /**
   * Whether to overscan the visible area to pre-render items slightly outside and
   * improve performance. Default is on.
   */
  constructor(options) {
    var _options$transitionDu;

    if (options === void 0) {
      options = {};
    }

    this.delegate = void 0;
    this.transitionDuration = void 0;
    this.anchorScrollPosition = void 0;
    this.anchorScrollPositionAtTop = void 0;
    this.shouldOverscan = void 0;
    this._collection = void 0;
    this._layout = void 0;
    this._contentSize = void 0;
    this._visibleRect = void 0;
    this._visibleLayoutInfos = void 0;
    this._reusableViews = void 0;
    this._visibleViews = void 0;
    this._renderedContent = void 0;
    this._children = void 0;
    this._invalidationContext = void 0;
    this._overscanManager = void 0;
    this._relayoutRaf = void 0;
    this._scrollAnimation = void 0;
    this._isScrolling = void 0;
    this._sizeUpdateQueue = void 0;
    this._animatedContentOffset = void 0;
    this._transaction = void 0;
    this._nextTransaction = void 0;
    this._transactionQueue = void 0;
    this._contentSize = new Size();
    this._visibleRect = new Rect();
    this._reusableViews = {};
    this._visibleLayoutInfos = new Map();
    this._visibleViews = new Map();
    this._renderedContent = new WeakMap();
    this._children = new Set();
    this._invalidationContext = null;
    this._overscanManager = new $d4638270963df552e2a603f0288c7$export$OverscanManager();
    this._scrollAnimation = null;
    this._isScrolling = false;
    this._sizeUpdateQueue = new Map();
    this._animatedContentOffset = new Point(0, 0);
    this._transaction = null;
    this._nextTransaction = null;
    this._transactionQueue = []; // Set options from passed object if given

    this.transitionDuration = (_options$transitionDu = options.transitionDuration) != null ? _options$transitionDu : 500;
    this.anchorScrollPosition = options.anchorScrollPosition || false;
    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;
    this.shouldOverscan = options.shouldOverscan !== false;

    for (let key of ['delegate', 'size', 'layout', 'collection']) {
      if (options[key]) {
        this[key] = options[key];
      }
    }
  }

  _setContentSize(size) {
    this._contentSize = size;
    this.delegate.setContentSize(size);
  }

  _setContentOffset(offset) {
    let rect = new Rect(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);
    this.delegate.setVisibleRect(rect);
  }
  /**
   * Get the size of the scrollable content.
   */


  get contentSize() {
    return this._contentSize;
  }
  /**
   * Get the collection view's currently visible rectangle.
   */


  get visibleRect() {
    return this._visibleRect;
  }
  /**
   * Set the collection view's currently visible rectangle.
   */


  set visibleRect(rect) {
    this._setVisibleRect(rect);
  }

  _setVisibleRect(rect, forceUpdate) {
    if (forceUpdate === void 0) {
      forceUpdate = false;
    }

    let current = this._visibleRect; // Ignore if the rects are equal

    if (rect.equals(current)) {
      return;
    }

    if (this.shouldOverscan) {
      this._overscanManager.setVisibleRect(rect);
    }

    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);

    this._resetAnimatedContentOffset();

    this._visibleRect = rect;

    if (shouldInvalidate) {
      this.relayout({
        offsetChanged: !rect.pointEquals(current),
        sizeChanged: !rect.sizeEquals(current)
      });
    } else {
      this.updateSubviews(forceUpdate);
    }
  }

  get collection() {
    return this._collection;
  }

  set collection(data) {
    this._setData(data);
  }

  _setData(data) {
    if (data === this._collection) {
      return;
    }

    if (this._collection) {
      this._runTransaction(() => {
        this._collection = data;
      }, this.transitionDuration > 0);
    } else {
      this._collection = data;
      this.reloadData();
    }
  }
  /**
   * Reloads the data from the data source and relayouts the collection view.
   * Does not animate any changes. Equivalent to re-assigning the same data source
   * to the collection view.
   */


  reloadData() {
    this.relayout({
      contentChanged: true
    });
  }
  /**
   * Returns the item with the given key.
   */


  getItem(key) {
    return this._collection ? this._collection.getItem(key) : null;
  }
  /**
   * Get the collection view's layout.
   */


  get layout() {
    return this._layout;
  }
  /**
   * Set the collection view's layout.
   */


  set layout(layout) {
    this.setLayout(layout);
  }
  /**
   * Sets the collection view's layout, optionally with an animated transition
   * from the current layout to the new layout.
   * @param layout The layout to switch to.
   * @param animated Whether to animate the layout change.
   */


  setLayout(layout, animated) {
    if (animated === void 0) {
      animated = false;
    }

    if (layout === this._layout) {
      return;
    }

    let applyLayout = () => {
      if (this._layout) {
        // @ts-ignore
        this._layout.virtualizer = null;
      }

      layout.virtualizer = this;
      this._layout = layout;
    };

    if (animated) {
      // Animated layout transitions are really simple, thanks to our transaction support.
      // We just set the layout inside a transaction action, which runs after the initial
      // layout infos for the animation are retrieved from the previous layout. Then, the
      // final layout infos are retrieved from the new layout, and animations occur.
      this._runTransaction(applyLayout);
    } else {
      applyLayout();
      this.relayout();
    }
  }

  _getReuseType(layoutInfo, content) {
    if (layoutInfo.type === 'item' && content) {
      let type = this.delegate.getType ? this.delegate.getType(content) : 'item';
      let reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;
      return {
        type,
        reuseType
      };
    }

    return {
      type: layoutInfo.type,
      reuseType: layoutInfo.type
    };
  }

  getReusableView(layoutInfo) {
    let content = this.getItem(layoutInfo.key);

    let {
      reuseType
    } = this._getReuseType(layoutInfo, content);

    if (!this._reusableViews[reuseType]) {
      this._reusableViews[reuseType] = [];
    }

    let reusable = this._reusableViews[reuseType];
    let view = reusable.length > 0 ? reusable.pop() : new ReusableView(this);
    view.viewType = reuseType;

    if (!this._animatedContentOffset.isOrigin()) {
      layoutInfo = layoutInfo.copy();
      layoutInfo.rect.x += this._animatedContentOffset.x;
      layoutInfo.rect.y += this._animatedContentOffset.y;
    }

    view.layoutInfo = layoutInfo;

    this._renderView(view);

    return view;
  }

  _renderView(reusableView) {
    let {
      type,
      key
    } = reusableView.layoutInfo;
    reusableView.content = this.getItem(key);
    reusableView.rendered = this._renderContent(type, reusableView.content);
  }

  _renderContent(type, content) {
    let cached = this._renderedContent.get(content);

    if (cached != null) {
      return cached;
    }

    let rendered = this.delegate.renderView(type, content);

    if (content) {
      this._renderedContent.set(content, rendered);
    }

    return rendered;
  }
  /**
   * Returns an array of all currently visible views, including both
   * item views and supplementary views.
   */


  get visibleViews() {
    return Array.from(this._visibleViews.values());
  }
  /**
   * Gets the visible view for the given type and key. Returns null if
   * the view is not currently visible.
   *
   * @param key The key of the view to retrieve.
   */


  getView(key) {
    return this._visibleViews.get(key) || null;
  }
  /**
   * Returns an array of visible views matching the given type.
   * @param type The view type to find.
   */


  getViewsOfType(type) {
    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);
  }
  /**
   * Returns the key for the given view. Returns null
   * if the view is not currently visible.
   */


  keyForView(view) {
    if (view && view.layoutInfo) {
      return view.layoutInfo.key;
    }

    return null;
  }
  /**
   * Returns the key for the item view currently at the given point.
   */


  keyAtPoint(point) {
    let rect = new Rect(point.x, point.y, 1, 1);
    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);
    let layoutInfo = layoutInfos[0];

    if (!layoutInfo) {
      return null;
    }

    return layoutInfo.key;
  }
  /**
   * Cleanup for when the Virtualizer will be unmounted.
   */


  willUnmount() {
    cancelAnimationFrame(this._relayoutRaf);
  }
  /**
   * Triggers a layout invalidation, and updates the visible subviews.
   */


  relayout(context) {
    if (context === void 0) {
      context = {};
    }

    // Ignore relayouts while animating the scroll position
    if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') {
      return;
    } // If we already scheduled a relayout, extend the invalidation
    // context so we coalesce multiple relayouts in the same frame.


    if (this._invalidationContext) {
      Object.assign(this._invalidationContext, context);
      return;
    }

    this._invalidationContext = context;
    this._relayoutRaf = requestAnimationFrame(() => {
      this._relayoutRaf = null;
      this.relayoutNow();
    });
  }
  /**
   * Performs a relayout immediately. Prefer {@link relayout} over this method
   * where possible, since it coalesces multiple layout passes in the same tick.
   */


  relayoutNow(context) {
    if (context === void 0) {
      context = this._invalidationContext || {};
    }

    // Cancel the scheduled relayout, since we're doing it now.
    if (this._relayoutRaf) {
      cancelAnimationFrame(this._relayoutRaf);
      this._relayoutRaf = null; // Update the provided context with the current invalidationContext since we are cancelling
      // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)

      context = _babelRuntimeHelpersExtends({}, this._invalidationContext, context);
    } // Reset the invalidation context


    this._invalidationContext = null; // Do nothing if we don't have a layout or content, or we are
    // in the middle of an animated scroll transition.

    if (!this.layout || !this._collection || this._scrollAnimation) {
      return;
    }

    let scrollAnchor = this._getScrollAnchor(); // Trigger the beforeLayout hook, if provided


    if (typeof context.beforeLayout === 'function') {
      context.beforeLayout();
    } // Validate the layout


    this.layout.validate(context);

    this._setContentSize(this.layout.getContentSize()); // Trigger the afterLayout hook, if provided


    if (typeof context.afterLayout === 'function') {
      context.afterLayout();
    } // Adjust scroll position based on scroll anchor, and constrain.
    // If the content changed, scroll to the top.


    let visibleRect = this.getVisibleRect();

    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);

    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;
    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;
    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));
    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));
    let hasLayoutUpdates = false;

    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {
      // If this is an animated relayout, we do not immediately scroll because it would be jittery.
      // Save the difference between the current and new content offsets, and apply it to the
      // individual content items instead. At the end of the animation, we'll reset and set the
      // scroll offset for real. This ensures jitter-free animation since we don't need to sync
      // the scroll animation and the content animation.
      if (context.animated || !this._animatedContentOffset.isOrigin()) {
        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;
        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;
        hasLayoutUpdates = this.updateSubviews(context.contentChanged);
      } else {
        this._setContentOffset(new Point(contentOffsetX, contentOffsetY));
      }
    } else {
      hasLayoutUpdates = this.updateSubviews(context.contentChanged);
    } // Apply layout infos, unless this is coming from an animated transaction


    if (!(context.transaction && context.animated)) {
      this._applyLayoutInfos();
    } // Wait for animations, and apply the afterAnimation hook, if provided


    if (context.animated && hasLayoutUpdates) {
      this._enableTransitions();

      let done = () => {
        this._disableTransitions(); // Reset scroll position after animations (see above comment).


        if (!this._animatedContentOffset.isOrigin()) {
          // Get the content offset to scroll to, taking _animatedContentOffset into account.
          let {
            x,
            y
          } = this.getVisibleRect();

          this._resetAnimatedContentOffset();

          this._setContentOffset(new Point(x, y));
        }

        if (typeof context.afterAnimation === 'function') {
          context.afterAnimation();
        }
      }; // Sometimes the animation takes slightly longer than expected.


      setTimeout(done, this.transitionDuration + 100);
      return;
    } else if (typeof context.afterAnimation === 'function') {
      context.afterAnimation();
    }
  }
  /**
   * Corrects DOM order of visible views to match item order of collection.
   */


  _correctItemOrder() {
    // Defer until after scrolling and animated transactions are complete
    if (this._isScrolling || this._transaction) {
      return;
    }

    for (let key of this._visibleLayoutInfos.keys()) {
      let view = this._visibleViews.get(key);

      this._children.delete(view);

      this._children.add(view);
    }
  }

  _enableTransitions() {
    this.delegate.beginAnimations();
  }

  _disableTransitions() {
    this.delegate.endAnimations();
  }

  _getScrollAnchor() {
    if (!this.anchorScrollPosition) {
      return null;
    }

    let visibleRect = this.getVisibleRect(); // Ask the delegate to provide a scroll anchor, if possible

    if (this.delegate.getScrollAnchor) {
      let key = this.delegate.getScrollAnchor(visibleRect);

      if (key) {
        let layoutInfo = this.layout.getLayoutInfo(key);
        let corner = layoutInfo.rect.getCornerInRect(visibleRect);

        if (corner) {
          let key = layoutInfo.key;
          let offset = layoutInfo.rect[corner].y - visibleRect.y;
          return {
            key,
            layoutInfo,
            corner,
            offset
          };
        }
      }
    } // No need to anchor the scroll position if it is at the top


    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) {
      return null;
    } // Find a view with a visible corner that has the smallest distance to the top of the collection view


    let cornerAnchor = null;

    for (let [key, view] of this._visibleViews) {
      let layoutInfo = view.layoutInfo;

      if (layoutInfo && layoutInfo.rect.area > 0) {
        let corner = layoutInfo.rect.getCornerInRect(visibleRect);

        if (corner) {
          let offset = layoutInfo.rect[corner].y - visibleRect.y;

          if (!cornerAnchor || offset < cornerAnchor.offset) {
            cornerAnchor = {
              key,
              layoutInfo,
              corner,
              offset
            };
          }
        }
      }
    }

    return cornerAnchor;
  }

  _restoreScrollAnchor(scrollAnchor, context) {
    let contentOffset = this.getVisibleRect();

    if (scrollAnchor) {
      var _context$transaction;

      let finalAnchor = (_context$transaction = context.transaction) != null && _context$transaction.animated ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);

      if (finalAnchor) {
        let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;
        contentOffset.y += adjustment;
      }
    }

    return contentOffset;
  }

  getVisibleRect() {
    let v = this.visibleRect;
    let x = v.x - this._animatedContentOffset.x;
    let y = v.y - this._animatedContentOffset.y;
    return new Rect(x, y, v.width, v.height);
  }

  getVisibleLayoutInfos() {
    let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();
    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);
    return this._visibleLayoutInfos;
  }

  _getLayoutInfoMap(rect, copy) {
    if (copy === void 0) {
      copy = false;
    }

    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);
    let map = new Map();

    for (let layoutInfo of layoutInfos) {
      if (copy) {
        layoutInfo = layoutInfo.copy();
      }

      map.set(layoutInfo.key, layoutInfo);
    }

    return map;
  }

  updateSubviews(forceUpdate) {
    if (forceUpdate === void 0) {
      forceUpdate = false;
    }

    if (!this._collection) {
      return;
    }

    let visibleLayoutInfos = this.getVisibleLayoutInfos();
    let currentlyVisible = this._visibleViews;
    let toAdd, toRemove, toUpdate; // If this is a force update, remove and re-add all views.
    // Otherwise, find and update the diff.

    if (forceUpdate) {
      toAdd = visibleLayoutInfos;
      toRemove = currentlyVisible;
      toUpdate = new Set();
    } else {
      ({
        toAdd,
        toRemove,
        toUpdate
      } = $eb5c48b3196adea28b2a65513c55f96$export$difference(currentlyVisible, visibleLayoutInfos));

      for (let key of toUpdate) {
        let view = currentlyVisible.get(key);

        if (!view || !view.layoutInfo) {
          continue;
        }

        let item = this.getItem(visibleLayoutInfos.get(key).key);

        if (view.content === item) {
          toUpdate.delete(key);
        } else {
          // If the view type changes, delete and recreate the view instead of updating
          let {
            reuseType
          } = this._getReuseType(view.layoutInfo, item);

          if (view.viewType !== reuseType) {
            toUpdate.delete(key);
            toAdd.add(key);
            toRemove.add(key);
          }
        }
      } // We are done if the sets are equal


      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {
        if (this._transaction) {
          this._applyLayoutInfos();
        }

        return;
      }
    } // Track views that should be removed. They are not removed from
    // the DOM immediately, since we may reuse and need to re-insert
    // them back into the DOM anyway.


    let removed = new Set();

    for (let key of toRemove.keys()) {
      let view = this._visibleViews.get(key);

      if (view) {
        removed.add(view);

        this._visibleViews.delete(key); // If we are in the middle of a transaction, wait until the end
        // of the animations to remove the views from the DOM. Also means
        // we can't reuse those views immediately.


        if (this._transaction) {
          this._transaction.toRemove.set(key, view);
        } else {
          this.reuseView(view);
        }
      }
    }

    for (let key of toAdd.keys()) {
      let layoutInfo = visibleLayoutInfos.get(key);
      let view; // If we're in a transaction, and a layout change happens
      // during the animations such that a view that was going
      // to be removed is now not, we don't create a new view
      // since the old one is still in the DOM, marked as toRemove.

      if (this._transaction) {
        // if transaction, get initial layout attributes for the animation
        if (this._transaction.initialLayoutInfo.has(key)) {
          layoutInfo = this._transaction.initialLayoutInfo.get(key);
        }

        view = this._transaction.toRemove.get(key);

        if (view) {
          this._transaction.toRemove.delete(key);

          this._applyLayoutInfo(view, layoutInfo);
        }
      }

      if (!view) {
        // Create or reuse a view for this row
        view = this.getReusableView(layoutInfo); // Add the view to the DOM if needed

        if (!removed.has(view)) {
          this._children.add(view);
        }
      }

      this._visibleViews.set(key, view);

      removed.delete(view);
    }

    for (let key of toUpdate) {
      let view = currentlyVisible.get(key);

      this._renderedContent.delete(key);

      this._renderView(view);
    } // Remove the remaining rows to delete from the DOM


    if (!this._transaction) {
      this.removeViews(removed);
    }

    this._correctItemOrder();

    this._flushVisibleViews();

    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());

    if (hasLayoutUpdates) {
      requestAnimationFrame(() => {
        // If we're in a transaction, apply animations to visible views
        // and "to be removed" views, which animate off screen.
        if (this._transaction) {
          requestAnimationFrame(() => this._applyLayoutInfos());
        }
      });
    }

    return hasLayoutUpdates;
  }

  afterRender() {
    if (this.shouldOverscan) {
      this._overscanManager.collectMetrics();
    }
  }

  _flushVisibleViews() {
    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy
    // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy
    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper
    // method to build the final tree.
    let viewsByParentKey = new Map([[null, []]]);

    for (let view of this._children) {
      if (!viewsByParentKey.has(view.layoutInfo.parentKey)) {
        viewsByParentKey.set(view.layoutInfo.parentKey, []);
      }

      viewsByParentKey.get(view.layoutInfo.parentKey).push(view);

      if (!viewsByParentKey.has(view.layoutInfo.key)) {
        viewsByParentKey.set(view.layoutInfo.key, []);
      }
    }

    let buildTree = (parent, views) => views.map(view => {
      let children = viewsByParentKey.get(view.layoutInfo.key);
      return this.delegate.renderWrapper(parent, view, children, childViews => buildTree(view, childViews));
    });

    let children = buildTree(null, viewsByParentKey.get(null));
    this.delegate.setVisibleViews(children);
  }

  _applyLayoutInfo(view, layoutInfo) {
    if (view.layoutInfo === layoutInfo) {
      return false;
    }

    view.layoutInfo = layoutInfo;
    return true;
  }

  _applyLayoutInfos() {
    let updated = false; // Apply layout infos to visible views

    for (let view of this._visibleViews.values()) {
      let cur = view.layoutInfo;

      if (cur) {
        let layoutInfo = this.layout.getLayoutInfo(cur.key);

        if (this._applyLayoutInfo(view, layoutInfo)) {
          updated = true;
        }
      }
    } // Apply final layout infos for views that will be removed


    if (this._transaction) {
      for (let view of this._transaction.toRemove.values()) {
        let cur = view.layoutInfo;
        let layoutInfo = this.layout.getLayoutInfo(cur.key);

        if (this._applyLayoutInfo(view, layoutInfo)) {
          updated = true;
        }
      }

      for (let view of this._transaction.removed.values()) {
        let cur = view.layoutInfo;
        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;
        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());

        if (this._applyLayoutInfo(view, layoutInfo)) {
          updated = true;
        }
      }
    }

    if (updated) {
      this._flushVisibleViews();
    }
  }

  _hasLayoutUpdates() {
    if (!this._transaction) {
      return false;
    }

    for (let view of this._visibleViews.values()) {
      let cur = view.layoutInfo;

      if (!cur) {
        return true;
      }

      let layoutInfo = this.layout.getLayoutInfo(cur.key);

      if ( // Uses equals rather than pointEquals so that width/height changes are taken into account
      !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) {
        return true;
      }
    }

    return false;
  }

  reuseView(view) {
    view.prepareForReuse();

    this._reusableViews[view.viewType].push(view);
  }

  removeViews(toRemove) {
    for (let view of toRemove) {
      this._children.delete(view);
    }
  }

  updateItemSize(key, size) {
    // TODO: we should be able to invalidate a single index path
    // @ts-ignore
    if (!this.layout.updateItemSize) {
      return;
    } // If the scroll position is currently animating, add the update
    // to a queue to be processed after the animation is complete.


    if (this._scrollAnimation) {
      this._sizeUpdateQueue.set(key, size);

      return;
    } // @ts-ignore


    let changed = this.layout.updateItemSize(key, size);

    if (changed) {
      this.relayout();
    }
  }

  startScrolling() {
    this._isScrolling = true;
  }

  endScrolling() {
    this._isScrolling = false;

    this._correctItemOrder();

    this._flushVisibleViews();
  }

  _resetAnimatedContentOffset() {
    // Reset the animated content offset of subviews. See comment in relayoutNow for details.
    if (!this._animatedContentOffset.isOrigin()) {
      this._animatedContentOffset = new Point(0, 0);

      this._applyLayoutInfos();
    }
  }
  /**
   * Scrolls the item with the given key into view, optionally with an animation.
   * @param key The key of the item to scroll into view.
   * @param duration The duration of the scroll animation.
   */


  scrollToItem(key, options) {
    if (!key) {
      return;
    }

    let layoutInfo = this.layout.getLayoutInfo(key);

    if (!layoutInfo) {
      return;
    }

    let {
      duration = 300,
      shouldScrollX = true,
      shouldScrollY = true,
      offsetX = 0,
      offsetY = 0
    } = options;
    let x = this.visibleRect.x;
    let y = this.visibleRect.y;
    let minX = layoutInfo.rect.x - offsetX;
    let minY = layoutInfo.rect.y - offsetY;
    let maxX = x + this.visibleRect.width;
    let maxY = y + this.visibleRect.height;

    if (shouldScrollX) {
      if (minX <= x || maxX === 0) {
        x = minX;
      } else if (layoutInfo.rect.maxX > maxX) {
        x += layoutInfo.rect.maxX - maxX;
      }
    }

    if (shouldScrollY) {
      if (minY <= y || maxY === 0) {
        y = minY;
      } else if (layoutInfo.rect.maxY > maxY) {
        y += layoutInfo.rect.maxY - maxY;
      }
    }

    return this.scrollTo(new Point(x, y), duration);
  }
  /**
   * Performs an animated scroll to the given offset.
   * @param offset - The offset to scroll to.
   * @param duration The duration of the animation.
   * @returns A promise that resolves when the animation is complete.
   */


  scrollTo(offset, duration) {
    if (duration === void 0) {
      duration = 300;
    }

    // Cancel the current scroll animation
    if (this._scrollAnimation) {
      this._scrollAnimation.cancel();

      this._scrollAnimation = null;
    } // Set the content offset synchronously if the duration is zero


    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {
      this._setContentOffset(offset);

      return Promise.resolve();
    }

    this.startScrolling();
    this._scrollAnimation = $c2209bcf49cd606639597eb5ee44c7c1$export$tween(this.visibleRect, offset, duration, $c2209bcf49cd606639597eb5ee44c7c1$export$easeOut, offset => {
      this._setContentOffset(offset);
    });

    this._scrollAnimation.then(() => {
      this._scrollAnimation = null; // Process view size updates that occurred during the animation.
      // Only views that are still visible will be actually updated.

      for (let [key, size] of this._sizeUpdateQueue) {
        this.updateItemSize(key, size);
      }

      this._sizeUpdateQueue.clear();

      this.relayout();

      this._processTransactionQueue();

      this.endScrolling();
    });

    return this._scrollAnimation;
  }

  _runTransaction(action, animated) {
    this._startTransaction();

    if (this._nextTransaction) {
      this._nextTransaction.actions.push(action);
    }

    this._endTransaction(animated);
  }

  _startTransaction() {
    if (!this._nextTransaction) {
      this._nextTransaction = new $b8a692491eed0a311c18a0d64051b3$export$Transaction();
    }

    this._nextTransaction.level++;
  }

  _endTransaction(animated) {
    if (!this._nextTransaction) {
      return false;
    } // Save whether the transaction should be animated.


    if (animated != null) {
      this._nextTransaction.animated = animated;
    } // If we haven't reached level 0, we are still in a
    // nested transaction. Wait for the parent to end.


    if (--this._nextTransaction.level > 0) {
      return false;
    } // Do nothing for empty transactions


    if (this._nextTransaction.actions.length === 0) {
      this._nextTransaction = null;
      return false;
    } // Default animations to true


    if (this._nextTransaction.animated == null) {
      this._nextTransaction.animated = true;
    } // Enqueue the transaction


    this._transactionQueue.push(this._nextTransaction);

    this._nextTransaction = null;

    this._processTransactionQueue();

    return true;
  }

  _processTransactionQueue() {
    // If the current transaction is animating, wait until the end
    // to process the next transaction.
    if (this._transaction || this._scrollAnimation) {
      return;
    }

    let next = this._transactionQueue.shift();

    if (next) {
      this._performTransaction(next);
    }
  }

  _getContentRect() {
    return new Rect(0, 0, this.contentSize.width, this.contentSize.height);
  }

  _performTransaction(transaction) {
    this._transaction = transaction;
    this.relayoutNow({
      transaction: transaction,
      animated: transaction.animated,
      beforeLayout: () => {
        // Get the initial layout infos for all views before the updates
        // so we can figure out which views to add and remove.
        if (transaction.animated) {
          transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);
        } // Apply the actions that occurred during this transaction


        for (let action of transaction.actions) {
          action();
        }
      },
      afterLayout: () => {
        // Get the final layout infos after the updates
        if (transaction.animated) {
          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());

          this._setupTransactionAnimations(transaction);
        } else {
          this._transaction = null;
        }
      },
      afterAnimation: () => {
        // Remove and reuse views when animations are done
        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {
          for (let view of $eb5c48b3196adea28b2a65513c55f96$export$concatIterators(transaction.toRemove.values(), transaction.removed.values())) {
            this._children.delete(view);

            this.reuseView(view);
          }
        }

        this._transaction = null; // Ensure DOM order is correct for accessibility after animations are complete

        this._correctItemOrder();

        this._flushVisibleViews();

        this._processTransactionQueue();
      }
    });
  }

  _setupTransactionAnimations(transaction) {
    let {
      initialMap,
      finalMap
    } = transaction; // Store initial and final layout infos for animations

    for (let [key, layoutInfo] of initialMap) {
      if (finalMap.has(key)) {
        // Store the initial layout info for use during animations.
        transaction.initialLayoutInfo.set(key, layoutInfo);
      } else {
        // This view was removed. Store the layout info for use
        // in Layout#getFinalLayoutInfo during animations.
        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);
      }
    } // Get initial layout infos for views that were added


    for (let [key, layoutInfo] of finalMap) {
      if (!initialMap.has(key)) {
        let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());
        transaction.initialLayoutInfo.set(key, initialLayoutInfo);
      }
    } // Figure out which views were removed.


    for (let [key, view] of this._visibleViews) {
      if (!finalMap.has(key)) {
        transaction.removed.set(key, view);

        this._visibleViews.delete(key); // In case something weird happened, where we have a view but no
        // initial layout info, use the one attached to the view.


        if (view.layoutInfo) {
          if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) {
            transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);
          }
        }
      }
    }
  }

}

function useVirtualizerState(opts) {
  let [visibleViews, setVisibleViews] = useState([]);
  let [contentSize, setContentSize] = useState(new Size());
  let [isAnimating, setAnimating] = useState(false);
  let [isScrolling, setScrolling] = useState(false);
  let virtualizer = useMemo(() => new $c28d52c9ae86344e9273f2344f3d5a45$export$Virtualizer(), []);
  virtualizer.delegate = {
    setVisibleViews,

    setVisibleRect(rect) {
      virtualizer.visibleRect = rect;
      opts.onVisibleRectChange(rect);
    },

    setContentSize,
    renderView: opts.renderView,
    renderWrapper: opts.renderWrapper,
    beginAnimations: () => setAnimating(true),
    endAnimations: () => setAnimating(false),
    getScrollAnchor: opts.getScrollAnchor
  };
  virtualizer.layout = opts.layout;
  virtualizer.collection = opts.collection;
  virtualizer.transitionDuration = opts.transitionDuration;
  useLayoutEffect(() => {
    virtualizer.afterRender();
  }); // eslint-disable-next-line arrow-body-style

  useEffect(() => {
    return () => virtualizer.willUnmount();
  }, []);
  return {
    virtualizer,
    visibleViews,
    setVisibleRect: useCallback(rect => {
      virtualizer.visibleRect = rect;
    }, [virtualizer]),
    contentSize,
    isAnimating,
    isScrolling,
    startScrolling: useCallback(() => {
      virtualizer.startScrolling();
      setScrolling(true);
    }, [virtualizer]),
    endScrolling: useCallback(() => {
      virtualizer.endScrolling();
      setScrolling(false);
    }, [virtualizer])
  };
}

exports.useVirtualizerState = useVirtualizerState;
//# sourceMappingURL=main.js.map
