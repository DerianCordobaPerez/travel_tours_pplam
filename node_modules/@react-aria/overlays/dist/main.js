var {
  VisuallyHidden
} = require("@react-aria/visually-hidden");

var _babelRuntimeHelpersInteropRequireDefault = $parcel$interopDefault(require("@babel/runtime/helpers/interopRequireDefault"));

var _reactDom = $parcel$interopDefault(require("react-dom"));

var _babelRuntimeHelpersObjectWithoutPropertiesLoose = $parcel$interopDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var {
  useFocusWithin,
  useInteractOutside
} = require("@react-aria/interactions");

var {
  useLocale,
  useMessageFormatter
} = require("@react-aria/i18n");

var {
  useLayoutEffect,
  useId,
  chain,
  getScrollParent,
  isIOS
} = require("@react-aria/utils");

var _react2 = require("react");

var _react = $parcel$interopDefault(_react2);

var {
  useCallback,
  useRef,
  useState,
  useEffect,
  useContext,
  useMemo
} = _react2;

var _domHelpersOwnerDocument = $parcel$interopDefault(require("dom-helpers/ownerDocument"));

var _domHelpersQueryScrollTop = $parcel$interopDefault(require("dom-helpers/query/scrollTop"));

var _domHelpersQueryScrollLeft = $parcel$interopDefault(require("dom-helpers/query/scrollLeft"));

var _domHelpersQueryPosition = $parcel$interopDefault(require("dom-helpers/query/position"));

var _domHelpersQueryOffset = $parcel$interopDefault(require("dom-helpers/query/offset"));

var _domHelpersStyle = $parcel$interopDefault(require("dom-helpers/style"));

var _babelRuntimeHelpersExtends = $parcel$interopDefault(require("@babel/runtime/helpers/extends"));

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

const $c13020473a0fe27b1a1c4797269d1704$var$AXIS = {
  top: 'top',
  bottom: 'top',
  left: 'left',
  right: 'left'
};
const $c13020473a0fe27b1a1c4797269d1704$var$FLIPPED_DIRECTION = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
};
const $c13020473a0fe27b1a1c4797269d1704$var$CROSS_AXIS = {
  top: 'left',
  left: 'top'
};
const $c13020473a0fe27b1a1c4797269d1704$var$AXIS_SIZE = {
  top: 'height',
  left: 'width'
};
const $c13020473a0fe27b1a1c4797269d1704$var$PARSED_PLACEMENT_CACHE = {}; // @ts-ignore

let $c13020473a0fe27b1a1c4797269d1704$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;

function $c13020473a0fe27b1a1c4797269d1704$var$getContainerDimensions(containerNode) {
  let width = 0,
      height = 0,
      top = 0,
      left = 0;
  let scroll = {};

  if (containerNode.tagName === 'BODY') {
    var _visualViewport$width, _visualViewport$heigh;

    width = (_visualViewport$width = $c13020473a0fe27b1a1c4797269d1704$var$visualViewport == null ? void 0 : $c13020473a0fe27b1a1c4797269d1704$var$visualViewport.width) != null ? _visualViewport$width : document.documentElement.clientWidth;
    height = (_visualViewport$heigh = $c13020473a0fe27b1a1c4797269d1704$var$visualViewport == null ? void 0 : $c13020473a0fe27b1a1c4797269d1704$var$visualViewport.height) != null ? _visualViewport$heigh : document.documentElement.clientHeight;
    scroll.top = _domHelpersQueryScrollTop(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollLeft(containerNode);
  } else {
    ({
      width,
      height,
      top,
      left
    } = _domHelpersQueryOffset(containerNode));
    scroll.top = _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(containerNode);
  }

  return {
    width,
    height,
    scroll,
    top,
    left
  };
}

function $c13020473a0fe27b1a1c4797269d1704$var$getScroll(node) {
  return {
    top: node.scrollTop,
    left: node.scrollLeft,
    width: node.scrollWidth,
    height: node.scrollHeight
  };
}

function $c13020473a0fe27b1a1c4797269d1704$var$getDelta(axis, offset, size, containerDimensions, padding) {
  let containerScroll = containerDimensions.scroll[axis];
  let containerHeight = containerDimensions[$c13020473a0fe27b1a1c4797269d1704$var$AXIS_SIZE[axis]];
  let startEdgeOffset = offset - padding - containerScroll;
  let endEdgeOffset = offset + padding - containerScroll + size;

  if (startEdgeOffset < 0) {
    return -startEdgeOffset;
  } else if (endEdgeOffset > containerHeight) {
    return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);
  } else {
    return 0;
  }
}

function $c13020473a0fe27b1a1c4797269d1704$var$getMargins(node) {
  let style = window.getComputedStyle(node);
  return {
    top: parseInt(style.marginTop, 10) || 0,
    bottom: parseInt(style.marginBottom, 10) || 0,
    left: parseInt(style.marginLeft, 10) || 0,
    right: parseInt(style.marginRight, 10) || 0
  };
}

function $c13020473a0fe27b1a1c4797269d1704$var$parsePlacement(input) {
  if ($c13020473a0fe27b1a1c4797269d1704$var$PARSED_PLACEMENT_CACHE[input]) {
    return $c13020473a0fe27b1a1c4797269d1704$var$PARSED_PLACEMENT_CACHE[input];
  }

  let [placement, crossPlacement] = input.split(' ');
  let axis = $c13020473a0fe27b1a1c4797269d1704$var$AXIS[placement] || 'right';
  let crossAxis = $c13020473a0fe27b1a1c4797269d1704$var$CROSS_AXIS[axis];

  if (!$c13020473a0fe27b1a1c4797269d1704$var$AXIS[crossPlacement]) {
    crossPlacement = 'center';
  }

  let size = $c13020473a0fe27b1a1c4797269d1704$var$AXIS_SIZE[axis];
  let crossSize = $c13020473a0fe27b1a1c4797269d1704$var$AXIS_SIZE[crossAxis];
  $c13020473a0fe27b1a1c4797269d1704$var$PARSED_PLACEMENT_CACHE[input] = {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size,
    crossSize
  };
  return $c13020473a0fe27b1a1c4797269d1704$var$PARSED_PLACEMENT_CACHE[input];
}

function $c13020473a0fe27b1a1c4797269d1704$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned) {
  let {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size,
    crossSize
  } = placementInfo;
  let position = {}; // button position

  position[crossAxis] = childOffset[crossAxis];

  if (crossPlacement === 'center') {
    //  + (button size / 2) - (overlay size / 2)
    // at this point the overlay center should match the button center
    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;
  } else if (crossPlacement !== crossAxis) {
    //  + (button size) - (overlay size)
    // at this point the overlay bottom should match the button bottom
    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];
  }
  /* else {
   the overlay top should match the button top
  } */
  // add the crossOffset from props


  position[crossAxis] += crossOffset; // this is button center position - the overlay size + half of the button to align bottom of overlay with button center

  let minViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2 - overlaySize[crossSize]; // this is button position of center, aligns top of overlay with button center

  let maxViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2; // clamp it into the range of the min/max positions

  position[crossAxis] = Math.min(Math.max(minViablePosition, position[crossAxis]), maxViablePosition); // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.

  if (placement === axis) {
    // If the container is positioned (non-static), then we use the container's actual
    // height, as `bottom` will be relative to this height.  But if the container is static,
    // then it can only be the `document.body`, and `bottom` will be relative to _its_
    // container, which should be as large as boundaryDimensions.
    const containerHeight = isContainerPositioned ? containerOffsetWithBoundary[size] : boundaryDimensions[size];
    position[$c13020473a0fe27b1a1c4797269d1704$var$FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);
  } else {
    position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);
  }

  return position;
}

function $c13020473a0fe27b1a1c4797269d1704$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding) {
  return position.top != null // We want the distance between the top of the overlay to the bottom of the boundary
  ? Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top - ( // this is the bottom of the boundary
  containerOffsetWithBoundary.top + position.top) // this is the top of the overlay
  - (margins.top + margins.bottom + padding) // save additional space for margin and padding
  ) // We want the distance between the top of the trigger to the top of the boundary
  : Math.max(0, childOffset.top + containerOffsetWithBoundary.top - ( // this is the top of the trigger
  boundaryDimensions.top + boundaryDimensions.scroll.top) // this is the top of the boundary
  - (margins.top + margins.bottom + padding) // save additional space for margin and padding
  );
}

function $c13020473a0fe27b1a1c4797269d1704$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {
  let {
    placement,
    axis,
    size
  } = placementInfo;

  if (placement === axis) {
    return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$c13020473a0fe27b1a1c4797269d1704$var$FLIPPED_DIRECTION[axis]] - padding);
  }

  return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[$c13020473a0fe27b1a1c4797269d1704$var$FLIPPED_DIRECTION[axis]] - padding);
}

function $c13020473a0fe27b1a1c4797269d1704$export$calculatePositionInternal(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned) {
  let placementInfo = $c13020473a0fe27b1a1c4797269d1704$var$parsePlacement(placementInput);
  let {
    size,
    crossAxis,
    crossSize,
    placement,
    crossPlacement
  } = placementInfo;
  let position = $c13020473a0fe27b1a1c4797269d1704$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);
  let normalizedOffset = offset;
  let space = $c13020473a0fe27b1a1c4797269d1704$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo); // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip

  if (flip && scrollSize[size] > space) {
    let flippedPlacementInfo = $c13020473a0fe27b1a1c4797269d1704$var$parsePlacement($c13020473a0fe27b1a1c4797269d1704$var$FLIPPED_DIRECTION[placement] + " " + crossPlacement);
    let flippedPosition = $c13020473a0fe27b1a1c4797269d1704$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);
    let flippedSpace = $c13020473a0fe27b1a1c4797269d1704$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo); // If the available space for the flipped position is greater than the original available space, flip.

    if (flippedSpace > space) {
      placementInfo = flippedPlacementInfo;
      position = flippedPosition;
      normalizedOffset = offset;
    }
  }

  let delta = $c13020473a0fe27b1a1c4797269d1704$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;
  let maxHeight = $c13020473a0fe27b1a1c4797269d1704$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding);
  overlaySize.height = Math.min(overlaySize.height, maxHeight);
  position = $c13020473a0fe27b1a1c4797269d1704$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);
  delta = $c13020473a0fe27b1a1c4797269d1704$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;
  let arrowPosition = {};
  arrowPosition[crossAxis] = childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;
  return {
    position,
    maxHeight: maxHeight,
    arrowOffsetLeft: arrowPosition.left,
    arrowOffsetTop: arrowPosition.top,
    placement: placementInfo.placement
  };
}
/**
 * Determines where to place the overlay with regards to the target and the position of an optional indicator.
 */


function $c13020473a0fe27b1a1c4797269d1704$export$calculatePosition(opts) {
  let {
    placement,
    targetNode,
    overlayNode,
    scrollNode,
    padding,
    shouldFlip,
    boundaryElement,
    offset,
    crossOffset
  } = opts;
  let container = overlayNode.offsetParent || document.body;
  let isBodyContainer = container.tagName === 'BODY';
  const containerPositionStyle = window.getComputedStyle(container).position;
  let isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== 'static';
  let childOffset = isBodyContainer ? _domHelpersQueryOffset(targetNode) : _domHelpersQueryPosition(targetNode, container);

  if (!isBodyContainer) {
    childOffset.top += parseInt(_domHelpersStyle(targetNode, 'marginTop'), 10) || 0;
    childOffset.left += parseInt(_domHelpersStyle(targetNode, 'marginLeft'), 10) || 0;
  }

  let overlaySize = _domHelpersQueryOffset(overlayNode);

  let margins = $c13020473a0fe27b1a1c4797269d1704$var$getMargins(overlayNode);
  overlaySize.width += margins.left + margins.right;
  overlaySize.height += margins.top + margins.bottom;
  let scrollSize = $c13020473a0fe27b1a1c4797269d1704$var$getScroll(scrollNode);
  let boundaryDimensions = $c13020473a0fe27b1a1c4797269d1704$var$getContainerDimensions(boundaryElement);
  let containerOffsetWithBoundary = boundaryElement.tagName === 'BODY' ? _domHelpersQueryOffset(container) : _domHelpersQueryPosition(container, boundaryElement);
  return $c13020473a0fe27b1a1c4797269d1704$export$calculatePositionInternal(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned);
}

// This behavior moved from useOverlayTrigger to useOverlayPosition.
// For backward compatibility, where useOverlayTrigger handled hiding the popover on close,
// it sets a close function here mapped from the trigger element. This way we can avoid
// forcing users to pass an onClose function to useOverlayPosition which could be considered
// a breaking change.
const $ceea668dd9ec3b754bdc10a8bbb8$export$onCloseMap = new WeakMap();

/** @private */
function $ceea668dd9ec3b754bdc10a8bbb8$export$useCloseOnScroll(opts) {
  let {
    triggerRef,
    isOpen,
    onClose
  } = opts;
  useEffect(() => {
    if (!isOpen) {
      return;
    }

    let onScroll = e => {
      // Ignore if scrolling an scrollable region outside the trigger's tree.
      let target = e.target;

      if (!triggerRef.current || !target.contains(triggerRef.current)) {
        return;
      }

      let onCloseHandler = onClose || $ceea668dd9ec3b754bdc10a8bbb8$export$onCloseMap.get(triggerRef.current);

      if (onCloseHandler) {
        onCloseHandler();
      }
    };

    window.addEventListener('scroll', onScroll, true);
    return () => {
      window.removeEventListener('scroll', onScroll, true);
    };
  }, [isOpen, onClose, triggerRef]);
}

// @ts-ignore
let $adfbd034e9bc71c1$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;
/**
 * Handles positioning overlays like popovers and menus relative to a trigger
 * element, and updating the position when the window resizes.
 */

function useOverlayPosition(props) {
  let {
    direction
  } = useLocale();
  let {
    targetRef,
    overlayRef,
    scrollRef = overlayRef,
    placement = 'bottom',
    containerPadding = 12,
    shouldFlip = true,
    boundaryElement = typeof document !== 'undefined' ? document.body : null,
    offset = 0,
    crossOffset = 0,
    shouldUpdatePosition = true,
    isOpen = true,
    onClose
  } = props;
  let [position, setPosition] = useState({
    position: {},
    arrowOffsetLeft: undefined,
    arrowOffsetTop: undefined,
    maxHeight: undefined,
    placement: undefined
  });
  let deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction];
  let updatePosition = useCallback(() => {
    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) {
      return;
    }

    setPosition($c13020473a0fe27b1a1c4797269d1704$export$calculatePosition({
      placement: $adfbd034e9bc71c1$var$translateRTL(placement, direction),
      overlayNode: overlayRef.current,
      targetNode: targetRef.current,
      scrollNode: scrollRef.current,
      padding: containerPadding,
      shouldFlip,
      boundaryElement,
      offset,
      crossOffset
    }));
  }, deps); // Update position when anything changes

  useLayoutEffect(updatePosition, deps); // Update position on window resize

  $adfbd034e9bc71c1$var$useResize(updatePosition); // Reposition the overlay and do not close on scroll while the visual viewport is resizing.
  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.

  let isResizing = useRef(false);
  useLayoutEffect(() => {
    let timeout;

    let onResize = () => {
      isResizing.current = true;
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        isResizing.current = false;
      }, 500);
      updatePosition();
    };

    $adfbd034e9bc71c1$var$visualViewport == null ? void 0 : $adfbd034e9bc71c1$var$visualViewport.addEventListener('resize', onResize);
    return () => {
      $adfbd034e9bc71c1$var$visualViewport == null ? void 0 : $adfbd034e9bc71c1$var$visualViewport.removeEventListener('resize', onResize);
    };
  }, [updatePosition]);
  let close = useCallback(() => {
    if (!isResizing.current) {
      onClose();
    }
  }, [onClose, isResizing]); // When scrolling a parent scrollable region of the trigger (other than the body),
  // we hide the popover. Otherwise, its position would be incorrect.

  $ceea668dd9ec3b754bdc10a8bbb8$export$useCloseOnScroll({
    triggerRef: targetRef,
    isOpen,
    onClose: onClose ? close : undefined
  });
  return {
    overlayProps: {
      style: _babelRuntimeHelpersExtends({
        position: 'absolute',
        zIndex: 100000
      }, position.position, {
        maxHeight: position.maxHeight
      })
    },
    placement: position.placement,
    arrowProps: {
      style: {
        left: position.arrowOffsetLeft,
        top: position.arrowOffsetTop
      }
    },
    updatePosition
  };
}

exports.useOverlayPosition = useOverlayPosition;

function $adfbd034e9bc71c1$var$useResize(onResize) {
  useLayoutEffect(() => {
    window.addEventListener('resize', onResize, false);
    return () => {
      window.removeEventListener('resize', onResize, false);
    };
  }, [onResize]);
}

function $adfbd034e9bc71c1$var$translateRTL(position, direction) {
  if (direction === 'rtl') {
    return position.replace('start', 'right').replace('end', 'left');
  }

  return position.replace('start', 'left').replace('end', 'right');
}

const $a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays = [];
/**
 * Provides the behavior for overlays such as dialogs, popovers, and menus.
 * Hides the overlay when the user interacts outside it, when the Escape key is pressed,
 * or optionally, on blur. Only the top-most overlay will close at once.
 */

function useOverlay(props, ref) {
  let {
    onClose,
    shouldCloseOnBlur,
    isOpen,
    isDismissable = false,
    isKeyboardDismissDisabled = false,
    shouldCloseOnInteractOutside
  } = props; // Add the overlay ref to the stack of visible overlays on mount, and remove on unmount.

  useEffect(() => {
    if (isOpen) {
      $a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays.push(ref);
    }

    return () => {
      let index = $a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays.indexOf(ref);

      if (index >= 0) {
        $a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays.splice(index, 1);
      }
    };
  }, [isOpen, ref]); // Only hide the overlay when it is the topmost visible overlay in the stack.

  let onHide = () => {
    if ($a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays[$a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays.length - 1] === ref && onClose) {
      onClose();
    }
  };

  let onInteractOutsideStart = e => {
    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {
      if ($a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays[$a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays.length - 1] === ref) {
        e.stopPropagation();
        e.preventDefault();
      }
    }
  };

  let onInteractOutside = e => {
    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {
      if ($a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays[$a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays.length - 1] === ref) {
        e.stopPropagation();
        e.preventDefault();
      }

      onHide();
    }
  }; // Handle the escape key


  let onKeyDown = e => {
    if (e.key === 'Escape' && !isKeyboardDismissDisabled) {
      e.preventDefault();
      onHide();
    }
  }; // Handle clicking outside the overlay to close it


  useInteractOutside({
    ref,
    onInteractOutside: isDismissable ? onInteractOutside : null,
    onInteractOutsideStart
  });
  let {
    focusWithinProps
  } = useFocusWithin({
    isDisabled: !shouldCloseOnBlur,
    onBlurWithin: e => {
      if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.relatedTarget)) {
        onClose();
      }
    }
  });

  let onPointerDownUnderlay = e => {
    // fixes a firefox issue that starts text selection https://bugzilla.mozilla.org/show_bug.cgi?id=1675846
    if (e.target === e.currentTarget) {
      e.preventDefault();
    }
  };

  return {
    overlayProps: _babelRuntimeHelpersExtends({
      onKeyDown
    }, focusWithinProps),
    underlayProps: {
      onPointerDown: onPointerDownUnderlay
    }
  };
}

exports.useOverlay = useOverlay;

/**
 * Handles the behavior and accessibility for an overlay trigger, e.g. a button
 * that opens a popover, menu, or other overlay that is positioned relative to the trigger.
 */
function useOverlayTrigger(props, state, ref) {
  let {
    type
  } = props;
  let {
    isOpen
  } = state; // Backward compatibility. Share state close function with useOverlayPosition so it can close on scroll
  // without forcing users to pass onClose.

  useEffect(() => {
    if (ref && ref.current) {
      $ceea668dd9ec3b754bdc10a8bbb8$export$onCloseMap.set(ref.current, state.close);
    }
  }); // Aria 1.1 supports multiple values for aria-haspopup other than just menus.
  // https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup
  // However, we only add it for menus for now because screen readers often
  // announce it as a menu even for other values.

  let ariaHasPopup = undefined;

  if (type === 'menu') {
    ariaHasPopup = true;
  } else if (type === 'listbox') {
    ariaHasPopup = 'listbox';
  }

  let overlayId = useId();
  return {
    triggerProps: {
      'aria-haspopup': ariaHasPopup,
      'aria-expanded': isOpen,
      'aria-controls': isOpen ? overlayId : null
    },
    overlayProps: {
      id: overlayId
    }
  };
}

exports.useOverlayTrigger = useOverlayTrigger;
// @ts-ignore
const $a21edfc55f5392c9a20c9978f0e487$var$visualViewport = typeof window !== 'undefined' && window.visualViewport; // HTML input types that do not cause the software keyboard to appear.

const $a21edfc55f5392c9a20c9978f0e487$var$nonTextInputTypes = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset']);
/**
 * Prevents scrolling on the document body on mount, and
 * restores it on unmount. Also ensures that content does not
 * shift due to the scrollbars disappearing.
 */

function usePreventScroll(options) {
  if (options === void 0) {
    options = {};
  }

  let {
    isDisabled
  } = options;
  useLayoutEffect(() => {
    if (isDisabled) {
      return;
    }

    if (isIOS()) {
      return $a21edfc55f5392c9a20c9978f0e487$var$preventScrollMobileSafari();
    } else {
      return $a21edfc55f5392c9a20c9978f0e487$var$preventScrollStandard();
    }
  }, [isDisabled]);
} // For most browsers, all we need to do is set `overflow: hidden` on the root element, and
// add some padding to prevent the page from shifting when the scrollbar is hidden.


exports.usePreventScroll = usePreventScroll;

function $a21edfc55f5392c9a20c9978f0e487$var$preventScrollStandard() {
  return chain($a21edfc55f5392c9a20c9978f0e487$var$setStyle(document.documentElement, 'paddingRight', window.innerWidth - document.documentElement.clientWidth + "px"), $a21edfc55f5392c9a20c9978f0e487$var$setStyle(document.documentElement, 'overflow', 'hidden'));
} // Mobile Safari is a whole different beast. Even with overflow: hidden,
// it still scrolls the page in many situations:
//
// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.
// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of
//    it, so it becomes scrollable.
// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.
//    This may cause even fixed position elements to scroll off the screen.
// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always
//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.
//
// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:
//
// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling
//    on the window.
// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the
//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.
// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.
// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top
//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element
//    into view ourselves, without scrolling the whole page.
// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the
//    same visually, but makes the actual scroll position always zero. This is required to make all of the
//    above work or Safari will still try to scroll the page when focusing an input.
// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting
//    to navigate to an input with the next/previous buttons that's outside a modal.


function $a21edfc55f5392c9a20c9978f0e487$var$preventScrollMobileSafari() {
  let scrollable;
  let lastY = 0;

  let onTouchStart = e => {
    // Store the nearest scrollable parent element from the element that the user touched.
    scrollable = getScrollParent(e.target);

    if (scrollable === document.documentElement && scrollable === document.body) {
      return;
    }

    lastY = e.changedTouches[0].pageY;
  };

  let onTouchMove = e => {
    // Prevent scrolling the window.
    if (scrollable === document.documentElement || scrollable === document.body) {
      e.preventDefault();
      return;
    } // Prevent scrolling up when at the top and scrolling down when at the bottom
    // of a nested scrollable area, otherwise mobile Safari will start scrolling
    // the window instead. Unfortunately, this disables bounce scrolling when at
    // the top but it's the best we can do.


    let y = e.changedTouches[0].pageY;
    let scrollTop = scrollable.scrollTop;
    let bottom = scrollable.scrollHeight - scrollable.clientHeight;

    if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) {
      e.preventDefault();
    }

    lastY = y;
  };

  let onTouchEnd = e => {
    let target = e.target;

    if (target instanceof HTMLInputElement && !$a21edfc55f5392c9a20c9978f0e487$var$nonTextInputTypes.has(target.type)) {
      e.preventDefault(); // Apply a transform to trick Safari into thinking the input is at the top of the page
      // so it doesn't try to scroll it into view. When tapping on an input, this needs to
      // be done before the "focus" event, so we have to focus the element ourselves.

      target.style.transform = 'translateY(-2000px)';
      target.focus();
      requestAnimationFrame(() => {
        target.style.transform = '';
      });
    }
  };

  let onFocus = e => {
    let target = e.target;

    if (target instanceof HTMLInputElement && !$a21edfc55f5392c9a20c9978f0e487$var$nonTextInputTypes.has(target.type)) {
      // Transform also needs to be applied in the focus event in cases where focus moves
      // software keyboard. In these cases, it seems applying the transform in the focus event
      // is good enough, whereas when tapping an input, it must be done before the focus event. 🤷‍♂️
      target.style.transform = 'translateY(-2000px)';
      requestAnimationFrame(() => {
        target.style.transform = ''; // This will have prevented the browser from scrolling the focused element into view,
        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.

        if ($a21edfc55f5392c9a20c9978f0e487$var$visualViewport) {
          if ($a21edfc55f5392c9a20c9978f0e487$var$visualViewport.height < window.innerHeight) {
            // If the keyboard is already visible, do this after one additional frame
            // to wait for the transform to be removed.
            requestAnimationFrame(() => {
              $a21edfc55f5392c9a20c9978f0e487$var$scrollIntoView(target);
            });
          } else {
            // Otherwise, wait for the visual viewport to resize before scrolling so we can
            // measure the correct position to scroll to.
            $a21edfc55f5392c9a20c9978f0e487$var$visualViewport.addEventListener('resize', () => $a21edfc55f5392c9a20c9978f0e487$var$scrollIntoView(target), {
              once: true
            });
          }
        }
      });
    }
  };

  let onWindowScroll = () => {
    // Last resort. If the window scrolled, scroll it back to the top.
    // It should always be at the top because the body will have a negative margin (see below).
    window.scrollTo(0, 0);
  }; // Record the original scroll position so we can restore it.
  // Then apply a negative margin to the body to offset it by the scroll position. This will
  // enable us to scroll the window to the top, which is required for the rest of this to work.


  let scrollX = window.pageXOffset;
  let scrollY = window.pageYOffset;
  let restoreStyles = chain($a21edfc55f5392c9a20c9978f0e487$var$setStyle(document.documentElement, 'paddingRight', window.innerWidth - document.documentElement.clientWidth + "px"), $a21edfc55f5392c9a20c9978f0e487$var$setStyle(document.documentElement, 'overflow', 'hidden'), $a21edfc55f5392c9a20c9978f0e487$var$setStyle(document.body, 'marginTop', "-" + scrollY + "px")); // Scroll to the top. The negative margin on the body will make this appear the same.

  window.scrollTo(0, 0);
  let removeEvents = chain($a21edfc55f5392c9a20c9978f0e487$var$addEvent(document, 'touchstart', onTouchStart, {
    passive: false,
    capture: true
  }), $a21edfc55f5392c9a20c9978f0e487$var$addEvent(document, 'touchmove', onTouchMove, {
    passive: false,
    capture: true
  }), $a21edfc55f5392c9a20c9978f0e487$var$addEvent(document, 'touchend', onTouchEnd, {
    passive: false,
    capture: true
  }), $a21edfc55f5392c9a20c9978f0e487$var$addEvent(document, 'focus', onFocus, true), $a21edfc55f5392c9a20c9978f0e487$var$addEvent(window, 'scroll', onWindowScroll));
  return () => {
    // Restore styles and scroll the page back to where it was.
    restoreStyles();
    removeEvents();
    window.scrollTo(scrollX, scrollY);
  };
} // Sets a CSS property on an element, and returns a function to revert it to the previous value.


function $a21edfc55f5392c9a20c9978f0e487$var$setStyle(element, style, value) {
  let cur = element.style[style];
  element.style[style] = value;
  return () => {
    element.style[style] = cur;
  };
} // Adds an event listener to an element, and returns a function to remove it.


function $a21edfc55f5392c9a20c9978f0e487$var$addEvent(target, event, handler, options) {
  target.addEventListener(event, handler, options);
  return () => {
    target.removeEventListener(event, handler, options);
  };
}

function $a21edfc55f5392c9a20c9978f0e487$var$scrollIntoView(target) {
  // Find the parent scrollable element and adjust the scroll position if the target is not already in view.
  let scrollable = getScrollParent(target);

  if (scrollable !== document.documentElement && scrollable !== document.body) {
    let scrollableTop = scrollable.getBoundingClientRect().top;
    let targetTop = target.getBoundingClientRect().top;

    if (targetTop > scrollableTop + target.clientHeight) {
      scrollable.scrollTop += targetTop - scrollableTop;
    }
  }
}

const $c5f9596976ab8bd94c5879001549a3e$var$Context = /*#__PURE__*/_react.createContext(null);
/**
 * Each ModalProvider tracks how many modals are open in its subtree. On mount, the modals
 * trigger `addModal` to increment the count, and trigger `removeModal` on unmount to decrement it.
 * This is done recursively so that all parent providers are incremented and decremented.
 * If the modal count is greater than zero, we add `aria-hidden` to this provider to hide its
 * subtree from screen readers. This is done using React context in order to account for things
 * like portals, which can cause the React tree and the DOM tree to differ significantly in structure.
 */


function ModalProvider(props) {
  let {
    children
  } = props;
  let parent = useContext($c5f9596976ab8bd94c5879001549a3e$var$Context);
  let [modalCount, setModalCount] = useState(0);
  let context = useMemo(() => ({
    parent,
    modalCount,

    addModal() {
      setModalCount(count => count + 1);

      if (parent) {
        parent.addModal();
      }
    },

    removeModal() {
      setModalCount(count => count - 1);

      if (parent) {
        parent.removeModal();
      }
    }

  }), [parent, modalCount]);
  return /*#__PURE__*/_react.createElement($c5f9596976ab8bd94c5879001549a3e$var$Context.Provider, {
    value: context
  }, children);
}

exports.ModalProvider = ModalProvider;

/**
 * Used to determine if the tree should be aria-hidden based on how many
 * modals are open.
 */
function useModalProvider() {
  let context = useContext($c5f9596976ab8bd94c5879001549a3e$var$Context);
  return {
    modalProviderProps: {
      'aria-hidden': context && context.modalCount > 0 ? true : null
    }
  };
}
/**
 * Creates a root node that will be aria-hidden if there are other modals open.
 */


exports.useModalProvider = useModalProvider;

function $c5f9596976ab8bd94c5879001549a3e$var$OverlayContainerDOM(props) {
  let {
    modalProviderProps
  } = useModalProvider();
  return /*#__PURE__*/_react.createElement("div", _babelRuntimeHelpersExtends({
    "data-overlay-container": true
  }, props, modalProviderProps));
}
/**
 * An OverlayProvider acts as a container for the top-level application.
 * Any application that uses modal dialogs or other overlays should
 * be wrapped in a `<OverlayProvider>`. This is used to ensure that
 * the main content of the application is hidden from screen readers
 * if a modal or other overlay is opened. Only the top-most modal or
 * overlay should be accessible at once.
 */


function OverlayProvider(props) {
  return /*#__PURE__*/_react.createElement(ModalProvider, null, /*#__PURE__*/_react.createElement($c5f9596976ab8bd94c5879001549a3e$var$OverlayContainerDOM, props));
}

exports.OverlayProvider = OverlayProvider;

/**
 * A container for overlays like modals and popovers. Renders the overlay
 * into a Portal which is placed at the end of the document body.
 * Also ensures that the overlay is hidden from screen readers if a
 * nested modal is opened. Only the top-most modal or overlay should
 * be accessible at once.
 */
function OverlayContainer(props) {
  let {
    portalContainer = document.body
  } = props,
      rest = _babelRuntimeHelpersObjectWithoutPropertiesLoose(props, ["portalContainer"]);

  _react.useEffect(() => {
    if (portalContainer.closest('[data-overlay-container]')) {
      throw new Error('An OverlayContainer must not be inside another container. Please change the portalContainer prop.');
    }
  }, [portalContainer]);

  let contents = /*#__PURE__*/_react.createElement(OverlayProvider, rest);

  return /*#__PURE__*/_reactDom.createPortal(contents, portalContainer);
}

exports.OverlayContainer = OverlayContainer;

/**
 * Hides content outside the current `<OverlayContainer>` from screen readers
 * on mount and restores it on unmount. Typically used by modal dialogs and
 * other types of overlays to ensure that only the top-most modal is
 * accessible at once.
 */
function useModal(options) {
  // Add aria-hidden to all parent providers on mount, and restore on unmount.
  let context = useContext($c5f9596976ab8bd94c5879001549a3e$var$Context);

  if (!context) {
    throw new Error('Modal is not contained within a provider');
  }

  useEffect(() => {
    if (options != null && options.isDisabled || !context || !context.parent) {
      return;
    } // The immediate context is from the provider containing this modal, so we only
    // want to trigger aria-hidden on its parents not on the modal provider itself.


    context.parent.addModal();
    return () => {
      if (context && context.parent) {
        context.parent.removeModal();
      }
    };
  }, [context, context.parent, options == null ? void 0 : options.isDisabled]);
  return {
    modalProps: {
      'data-ismodal': !(options != null && options.isDisabled)
    }
  };
}

exports.useModal = useModal;
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ar-AE.json
var $a8bb21dadcfaad10bb0a0bcf2b281764$exports = {};
$a8bb21dadcfaad10bb0a0bcf2b281764$exports = JSON.parse("{\"dismiss\":\"تجاهل\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/bg-BG.json
var $dafefe57ee4fa5270277199b63666456$exports = {};
$dafefe57ee4fa5270277199b63666456$exports = JSON.parse("{\"dismiss\":\"Отхвърляне\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/cs-CZ.json
var $c2158ac3aac63d05c0787f91c5e6$exports = {};
$c2158ac3aac63d05c0787f91c5e6$exports = JSON.parse("{\"dismiss\":\"Odstranit\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/da-DK.json
var $f7aea96abdaae1eb301c63fe67ff9fa$exports = {};
$f7aea96abdaae1eb301c63fe67ff9fa$exports = JSON.parse("{\"dismiss\":\"Luk\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/de-DE.json
var $f3491c664171e6b5e47db3baca390e$exports = {};
$f3491c664171e6b5e47db3baca390e$exports = JSON.parse("{\"dismiss\":\"Schließen\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/el-GR.json
var $da631def8a53d3d7ca63b5a989a2$exports = {};
$da631def8a53d3d7ca63b5a989a2$exports = JSON.parse("{\"dismiss\":\"Απόρριψη\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/en-US.json
var $fb4c477a38a74b935d35db24ae7$exports = {};
$fb4c477a38a74b935d35db24ae7$exports = JSON.parse("{\"dismiss\":\"Dismiss\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/es-ES.json
var $b6fd69f9d5c0d1736b0ffb60159dbd4$exports = {};
$b6fd69f9d5c0d1736b0ffb60159dbd4$exports = JSON.parse("{\"dismiss\":\"Descartar\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/et-EE.json
var $ba5713ed42715892c62c91f4a61185db$exports = {};
$ba5713ed42715892c62c91f4a61185db$exports = JSON.parse("{\"dismiss\":\"Lõpeta\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/fi-FI.json
var $d425c7f620a7cd6fec958b2d805b4748$exports = {};
$d425c7f620a7cd6fec958b2d805b4748$exports = JSON.parse("{\"dismiss\":\"Hylkää\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/fr-FR.json
var $a53b9b9e4ee3c32689ca1c9d37$exports = {};
$a53b9b9e4ee3c32689ca1c9d37$exports = JSON.parse("{\"dismiss\":\"Rejeter\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/he-IL.json
var $c53806192c6b46eb32dc82efae908cb$exports = {};
$c53806192c6b46eb32dc82efae908cb$exports = JSON.parse("{\"dismiss\":\"התעלם\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/hr-HR.json
var $cbbca9d8ba35e50d9d74ddc492ac95d5$exports = {};
$cbbca9d8ba35e50d9d74ddc492ac95d5$exports = JSON.parse("{\"dismiss\":\"Odbaci\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/hu-HU.json
var $b6e1f06770a0ad8a02049cb304d$exports = {};
$b6e1f06770a0ad8a02049cb304d$exports = JSON.parse("{\"dismiss\":\"Elutasítás\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/it-IT.json
var $b6c1d31d04e4e80df25d89ebefb38d6c$exports = {};
$b6c1d31d04e4e80df25d89ebefb38d6c$exports = JSON.parse("{\"dismiss\":\"Ignora\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ja-JP.json
var $a858c6dc87cf51add44cd600186b$exports = {};
$a858c6dc87cf51add44cd600186b$exports = JSON.parse("{\"dismiss\":\"閉じる\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ko-KR.json
var $bce3a6596f5d6bce7af4e1cdfe714b9$exports = {};
$bce3a6596f5d6bce7af4e1cdfe714b9$exports = JSON.parse("{\"dismiss\":\"무시\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/lt-LT.json
var $a80424d4da258b90efdca51671420e98$exports = {};
$a80424d4da258b90efdca51671420e98$exports = JSON.parse("{\"dismiss\":\"Atmesti\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/lv-LV.json
var $b7b9bc8c0cfc6eec9fa971e7b25cd656$exports = {};
$b7b9bc8c0cfc6eec9fa971e7b25cd656$exports = JSON.parse("{\"dismiss\":\"Nerādīt\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/nb-NO.json
var $e985758bae9fabb24500c21a0a00b725$exports = {};
$e985758bae9fabb24500c21a0a00b725$exports = JSON.parse("{\"dismiss\":\"Lukk\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/nl-NL.json
var $f05d419963f6daeda3bc9dbbe3cc02bd$exports = {};
$f05d419963f6daeda3bc9dbbe3cc02bd$exports = JSON.parse("{\"dismiss\":\"Negeren\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/pl-PL.json
var $c8fa3e85daf6d04ed07583e629c87ce4$exports = {};
$c8fa3e85daf6d04ed07583e629c87ce4$exports = JSON.parse("{\"dismiss\":\"Zignoruj\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/pt-BR.json
var $f06e8ad24001ed35ea808810226a15$exports = {};
$f06e8ad24001ed35ea808810226a15$exports = JSON.parse("{\"dismiss\":\"Descartar\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/pt-PT.json
var $fd097ce7a9000ad9750e5946ad880932$exports = {};
$fd097ce7a9000ad9750e5946ad880932$exports = JSON.parse("{\"dismiss\":\"Dispensar\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ro-RO.json
var $a20ad400f1086b2bea7f9791d7257ad$exports = {};
$a20ad400f1086b2bea7f9791d7257ad$exports = JSON.parse("{\"dismiss\":\"Revocare\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ru-RU.json
var $fc28441a9133071c2297a09b6b420dd$exports = {};
$fc28441a9133071c2297a09b6b420dd$exports = JSON.parse("{\"dismiss\":\"Пропустить\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sk-SK.json
var $a91ecad4479ad50b50aa177a2506dc$exports = {};
$a91ecad4479ad50b50aa177a2506dc$exports = JSON.parse("{\"dismiss\":\"Zrušiť\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sl-SI.json
var $f9693ead50748c9beb107ad23956eb9$exports = {};
$f9693ead50748c9beb107ad23956eb9$exports = JSON.parse("{\"dismiss\":\"Opusti\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sr-SP.json
var $b5e22101ce830f7d95581df69464b$exports = {};
$b5e22101ce830f7d95581df69464b$exports = JSON.parse("{\"dismiss\":\"Odbaci\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sv-SE.json
var $c0b006e739315f2d0109fd704d505d4d$exports = {};
$c0b006e739315f2d0109fd704d505d4d$exports = JSON.parse("{\"dismiss\":\"Avvisa\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/tr-TR.json
var $b2fcb8208d40a3677791cb274f5c23$exports = {};
$b2fcb8208d40a3677791cb274f5c23$exports = JSON.parse("{\"dismiss\":\"Kapat\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/uk-UA.json
var $bedf08a338a4a9658a5b3265b7ba64$exports = {};
$bedf08a338a4a9658a5b3265b7ba64$exports = JSON.parse("{\"dismiss\":\"Скасувати\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/zh-CN.json
var $b49f1939211bfd9e1f4f626061efad44$exports = {};
$b49f1939211bfd9e1f4f626061efad44$exports = JSON.parse("{\"dismiss\":\"取消\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/zh-TW.json
var $a878720d2a5fd83cfd5a0f74b64957e$exports = {};
$a878720d2a5fd83cfd5a0f74b64957e$exports = JSON.parse("{\"dismiss\":\"關閉\"}");

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// @ts-ignore
const $e0a65de2c0deb9a27bf483be129a43c1$var$intlMessages = {
  "ar-AE": _babelRuntimeHelpersInteropRequireDefault($a8bb21dadcfaad10bb0a0bcf2b281764$exports).default,
  "bg-BG": _babelRuntimeHelpersInteropRequireDefault($dafefe57ee4fa5270277199b63666456$exports).default,
  "cs-CZ": _babelRuntimeHelpersInteropRequireDefault($c2158ac3aac63d05c0787f91c5e6$exports).default,
  "da-DK": _babelRuntimeHelpersInteropRequireDefault($f7aea96abdaae1eb301c63fe67ff9fa$exports).default,
  "de-DE": _babelRuntimeHelpersInteropRequireDefault($f3491c664171e6b5e47db3baca390e$exports).default,
  "el-GR": _babelRuntimeHelpersInteropRequireDefault($da631def8a53d3d7ca63b5a989a2$exports).default,
  "en-US": _babelRuntimeHelpersInteropRequireDefault($fb4c477a38a74b935d35db24ae7$exports).default,
  "es-ES": _babelRuntimeHelpersInteropRequireDefault($b6fd69f9d5c0d1736b0ffb60159dbd4$exports).default,
  "et-EE": _babelRuntimeHelpersInteropRequireDefault($ba5713ed42715892c62c91f4a61185db$exports).default,
  "fi-FI": _babelRuntimeHelpersInteropRequireDefault($d425c7f620a7cd6fec958b2d805b4748$exports).default,
  "fr-FR": _babelRuntimeHelpersInteropRequireDefault($a53b9b9e4ee3c32689ca1c9d37$exports).default,
  "he-IL": _babelRuntimeHelpersInteropRequireDefault($c53806192c6b46eb32dc82efae908cb$exports).default,
  "hr-HR": _babelRuntimeHelpersInteropRequireDefault($cbbca9d8ba35e50d9d74ddc492ac95d5$exports).default,
  "hu-HU": _babelRuntimeHelpersInteropRequireDefault($b6e1f06770a0ad8a02049cb304d$exports).default,
  "it-IT": _babelRuntimeHelpersInteropRequireDefault($b6c1d31d04e4e80df25d89ebefb38d6c$exports).default,
  "ja-JP": _babelRuntimeHelpersInteropRequireDefault($a858c6dc87cf51add44cd600186b$exports).default,
  "ko-KR": _babelRuntimeHelpersInteropRequireDefault($bce3a6596f5d6bce7af4e1cdfe714b9$exports).default,
  "lt-LT": _babelRuntimeHelpersInteropRequireDefault($a80424d4da258b90efdca51671420e98$exports).default,
  "lv-LV": _babelRuntimeHelpersInteropRequireDefault($b7b9bc8c0cfc6eec9fa971e7b25cd656$exports).default,
  "nb-NO": _babelRuntimeHelpersInteropRequireDefault($e985758bae9fabb24500c21a0a00b725$exports).default,
  "nl-NL": _babelRuntimeHelpersInteropRequireDefault($f05d419963f6daeda3bc9dbbe3cc02bd$exports).default,
  "pl-PL": _babelRuntimeHelpersInteropRequireDefault($c8fa3e85daf6d04ed07583e629c87ce4$exports).default,
  "pt-BR": _babelRuntimeHelpersInteropRequireDefault($f06e8ad24001ed35ea808810226a15$exports).default,
  "pt-PT": _babelRuntimeHelpersInteropRequireDefault($fd097ce7a9000ad9750e5946ad880932$exports).default,
  "ro-RO": _babelRuntimeHelpersInteropRequireDefault($a20ad400f1086b2bea7f9791d7257ad$exports).default,
  "ru-RU": _babelRuntimeHelpersInteropRequireDefault($fc28441a9133071c2297a09b6b420dd$exports).default,
  "sk-SK": _babelRuntimeHelpersInteropRequireDefault($a91ecad4479ad50b50aa177a2506dc$exports).default,
  "sl-SI": _babelRuntimeHelpersInteropRequireDefault($f9693ead50748c9beb107ad23956eb9$exports).default,
  "sr-SP": _babelRuntimeHelpersInteropRequireDefault($b5e22101ce830f7d95581df69464b$exports).default,
  "sv-SE": _babelRuntimeHelpersInteropRequireDefault($c0b006e739315f2d0109fd704d505d4d$exports).default,
  "tr-TR": _babelRuntimeHelpersInteropRequireDefault($b2fcb8208d40a3677791cb274f5c23$exports).default,
  "uk-UA": _babelRuntimeHelpersInteropRequireDefault($bedf08a338a4a9658a5b3265b7ba64$exports).default,
  "zh-CN": _babelRuntimeHelpersInteropRequireDefault($b49f1939211bfd9e1f4f626061efad44$exports).default,
  "zh-TW": _babelRuntimeHelpersInteropRequireDefault($a878720d2a5fd83cfd5a0f74b64957e$exports).default
};

/**
 * A visually hidden button that can be used to allow screen reader
 * users to dismiss a modal or popup when there is no visual
 * affordance to do so.
 */
function DismissButton(props) {
  let {
    onDismiss
  } = props;
  let formatMessage = useMessageFormatter($e0a65de2c0deb9a27bf483be129a43c1$var$intlMessages);

  let onClick = () => {
    if (onDismiss) {
      onDismiss();
    }
  };

  return /*#__PURE__*/_react.createElement(VisuallyHidden, null, /*#__PURE__*/_react.createElement("button", {
    tabIndex: -1,
    "aria-label": formatMessage('dismiss'),
    onClick: onClick
  }));
}

exports.DismissButton = DismissButton;
// subtracted from when showing it again. When it reaches zero, aria-hidden is removed.
let $a683bb0d63d5b6f7885c12dcc6f96807$var$refCountMap = new WeakMap();
/**
 * Hides all elements in the DOM outside the given targets from screen readers using aria-hidden,
 * and returns a function to revert these changes. In addition, changes to the DOM are watched
 * and new elements outside the targets are automatically hidden.
 * @param targets - The elements that should remain visible.
 * @param root - Nothing will be hidden above this element.
 * @returns - A function to restore all hidden elements.
 */

function ariaHideOutside(targets, root) {
  if (root === void 0) {
    root = document.body;
  }

  let visibleNodes = new Set(targets);
  let hiddenNodes = new Set();
  let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node) {
      // If this node is a live announcer, add it to the set of nodes to keep visible.
      if (node instanceof HTMLElement && node.dataset.liveAnnouncer === 'true') {
        visibleNodes.add(node);
      } // Skip this node and its children if it is one of the target nodes, or a live announcer.
      // Also skip children of already hidden nodes, as aria-hidden is recursive.


      if (visibleNodes.has(node) || hiddenNodes.has(node.parentElement)) {
        return NodeFilter.FILTER_REJECT;
      } // VoiceOver on iOS has issues hiding elements with role="row". Hide the cells inside instead.
      // https://bugs.webkit.org/show_bug.cgi?id=222623


      if (node instanceof HTMLElement && node.getAttribute('role') === 'row') {
        return NodeFilter.FILTER_SKIP;
      } // Skip this node but continue to children if one of the targets is inside the node.


      if (targets.some(target => node.contains(target))) {
        return NodeFilter.FILTER_SKIP;
      }

      return NodeFilter.FILTER_ACCEPT;
    }

  });

  let hide = node => {
    var _refCountMap$get;

    let refCount = (_refCountMap$get = $a683bb0d63d5b6f7885c12dcc6f96807$var$refCountMap.get(node)) != null ? _refCountMap$get : 0; // If already aria-hidden, and the ref count is zero, then this element
    // was already hidden and there's nothing for us to do.

    if (node.getAttribute('aria-hidden') === 'true' && refCount === 0) {
      return;
    }

    if (refCount === 0) {
      node.setAttribute('aria-hidden', 'true');
    }

    hiddenNodes.add(node);
    $a683bb0d63d5b6f7885c12dcc6f96807$var$refCountMap.set(node, refCount + 1);
  };

  let node = walker.nextNode();

  while (node != null) {
    hide(node);
    node = walker.nextNode();
  }

  let observer = new MutationObserver(changes => {
    for (let change of changes) {
      if (change.type !== 'childList' || change.addedNodes.length === 0) {
        continue;
      } // If the parent element of the added nodes is not within one of the targets,
      // and not already inside a hidden node, hide all of the new children.


      if (![...visibleNodes, ...hiddenNodes].some(node => node.contains(change.target))) {
        for (let node of change.addedNodes) {
          if (node instanceof HTMLElement && node.dataset.liveAnnouncer === 'true') {
            visibleNodes.add(node);
          } else if (node instanceof Element) {
            hide(node);
          }
        }
      }
    }
  });
  observer.observe(root, {
    childList: true,
    subtree: true
  });
  return () => {
    observer.disconnect();

    for (let node of hiddenNodes) {
      let count = $a683bb0d63d5b6f7885c12dcc6f96807$var$refCountMap.get(node);

      if (count === 1) {
        node.removeAttribute('aria-hidden');
        $a683bb0d63d5b6f7885c12dcc6f96807$var$refCountMap.delete(node);
      } else {
        $a683bb0d63d5b6f7885c12dcc6f96807$var$refCountMap.set(node, count - 1);
      }
    }
  };
}

exports.ariaHideOutside = ariaHideOutside;
//# sourceMappingURL=main.js.map
