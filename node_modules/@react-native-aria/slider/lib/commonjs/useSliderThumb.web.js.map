{"version":3,"sources":["useSliderThumb.web.ts"],"names":["useSliderThumb","opts","state","index","isRequired","isDisabled","validationState","trackLayout","inputRef","isVertical","orientation","direction","undefined","addGlobalListener","removeGlobalListener","labelId","sliderIds","get","labelProps","fieldProps","trim","value","values","focusInput","current","isFocused","focusedThumb","stateRef","reverseX","currentPosition","moveProps","onMoveStart","setThumbDragging","onMove","deltaX","deltaY","pointerType","size","height","width","getThumbPercent","delta","step","setThumbValue","getThumbValue","setThumbPercent","onMoveEnd","setThumbEditable","focusableProps","onFocus","setFocusedThumb","onBlur","currentPointer","onDown","id","window","onUp","e","pointerId","changedTouches","identifier","inputProps","getThumbMinValue","getThumbMaxValue","getThumbValueLabel","parseFloat","target","thumbProps","onMouseDown","button","altKey","ctrlKey","metaKey","onPointerDown","onTouchStart"],"mappings":"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","sourcesContent":["import { AriaSliderThumbProps } from '@react-types/slider';\nimport {\n  clamp,\n  focusWithoutScrolling,\n  mergeProps,\n  useGlobalListeners,\n} from '@react-aria/utils';\nimport { getSliderThumbId, sliderIds } from './utils';\nimport React, {\n  ChangeEvent,\n  HTMLAttributes,\n  InputHTMLAttributes,\n  LabelHTMLAttributes,\n  RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n} from 'react';\nimport { SliderState } from '@react-stately/slider';\nimport { useFocusable } from '@react-aria/focus';\nimport { useLabel } from '@react-aria/label';\nimport { useMove } from './useMove';\nimport { isRTL } from '@react-native-aria/utils';\n\ninterface SliderThumbAria {\n  /** Props for the root thumb element; handles the dragging motion. */\n  thumbProps: HTMLAttributes<HTMLElement>;\n\n  /** Props for the visually hidden range input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>;\n\n  /** Props for the label element for this thumb (optional). */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>;\n}\n\ninterface SliderThumbOptions extends AriaSliderThumbProps {\n  /** A ref to the track element. */\n  trackLayout: any;\n  /** A ref to the thumb input element. */\n  inputRef: RefObject<HTMLInputElement>;\n}\n\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\nexport function useSliderThumb(\n  opts: SliderThumbOptions,\n  state: SliderState\n): SliderThumbAria {\n  let {\n    index,\n    isRequired,\n    isDisabled,\n    validationState,\n    trackLayout,\n    inputRef,\n  } = opts;\n\n  let isVertical = opts.orientation === 'vertical';\n\n  let direction = isRTL() ? 'rtl' : undefined;\n  let { addGlobalListener, removeGlobalListener } = useGlobalListeners();\n\n  let labelId = sliderIds.get(state);\n  const { labelProps, fieldProps } = useLabel({\n    ...opts,\n    'id': getSliderThumbId(state, index),\n    'aria-labelledby': `${labelId} ${opts['aria-labelledby'] ?? ''}`.trim(),\n  });\n\n  const value = state.values[index];\n\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n\n  const isFocused = state.focusedThumb === index;\n\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n\n  const stateRef = useRef<SliderState>(null);\n  stateRef.current = state;\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef<number>(null);\n  let { moveProps } = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove({ deltaX, deltaY, pointerType }) {\n      let size = isVertical ? trackLayout.height : trackLayout.width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current =\n          stateRef.current.getThumbPercent(index) * size;\n      }\n      if (pointerType === 'keyboard') {\n        // (invert left/right according to language direction) + (according to vertical)\n        let delta =\n          ((reverseX ? -deltaX : deltaX) + (isVertical ? -deltaY : -deltaY)) *\n          stateRef.current.step;\n        currentPosition.current += delta * size;\n        stateRef.current.setThumbValue(\n          index,\n          stateRef.current.getThumbValue(index) + delta\n        );\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n        currentPosition.current += delta;\n        stateRef.current.setThumbPercent(\n          index,\n          clamp(currentPosition.current / size, 0, 1)\n        );\n      }\n    },\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    },\n  });\n\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n\n  const { focusableProps } = useFocusable(\n    mergeProps(opts, {\n      onFocus: () => state.setFocusedThumb(index),\n      onBlur: () => state.setFocusedThumb(undefined),\n    }),\n    inputRef\n  );\n\n  let currentPointer = useRef<number | undefined>(undefined);\n  let onDown = (id?: number) => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n\n  let onUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      'type': 'range',\n      'tabIndex': !isDisabled ? 0 : undefined,\n      'min': state.getThumbMinValue(index),\n      'max': state.getThumbMaxValue(index),\n      'step': state.step,\n      'value': value,\n      'disabled': isDisabled,\n      'aria-orientation': opts.orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      'onChange': (e: ChangeEvent<HTMLInputElement>) => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      },\n    }),\n    thumbProps: !isDisabled\n      ? mergeProps(moveProps, {\n          onMouseDown: (e: React.MouseEvent<HTMLElement>) => {\n            if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n              return;\n            }\n            onDown();\n          },\n          onPointerDown: (e: React.PointerEvent<HTMLElement>) => {\n            if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n              return;\n            }\n            onDown(e.pointerId);\n          },\n          onTouchStart: (e: React.TouchEvent<HTMLElement>) => {\n            onDown(e.changedTouches[0].identifier);\n          },\n        })\n      : {},\n    labelProps,\n  };\n}\n"]}