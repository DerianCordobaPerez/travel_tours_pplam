{"version":3,"sources":["useSlider.ts"],"names":["useSlider","props","state","trackLayout","labelProps","fieldProps","isVertical","orientation","sliderIds","set","id","currentPointer","undefined","onDownTrack","e","clientX","clientY","direction","isDisabled","values","every","_","i","isThumbDragging","size","height","width","trackPosition","clickPosition","offset","percent","value","getPercentValue","closestThumb","split","findIndex","v","length","lastLeft","firstRight","Math","abs","isThumbEditable","preventDefault","setFocusedThumb","current","setThumbDragging","setThumbValue","groupProps","trackProps","onPress","locationX","locationY","nativeEvent","outputProps"],"mappings":"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","sourcesContent":["import { sliderIds } from './utils';\nimport { AriaSliderProps } from '@react-types/slider';\nimport React, { useRef } from 'react';\nimport { SliderState } from '@react-stately/slider';\nimport { useLabel } from '@react-aria/label';\nimport { isRTL } from '@react-native-aria/utils';\n\ninterface SliderAria {\n  /** Props for the label element. */\n  labelProps: any;\n\n  /** Props for the root element of the slider component; groups slider inputs. */\n  groupProps: any;\n\n  /** Props for the track element. */\n  trackProps: any;\n\n  /** Props for the output element, displaying the value of the slider thumbs. */\n  outputProps: any;\n}\n\n/**\n * Provides the behavior and accessibility implementation for a slider component representing one or more values.\n *\n * @param props Props for the slider.\n * @param state State for the slider, as returned by `useSliderState`.\n * @param trackRef Ref for the \"track\" element.  The width of this element provides the \"length\"\n * of the track -- the span of one dimensional space that the slider thumb can be.  It also\n * accepts click and drag motions, so that the closest thumb will follow clicks and drags on\n * the track.\n */\nexport function useSlider(\n  props: AriaSliderProps,\n  state: SliderState,\n  trackLayout: any\n): SliderAria {\n  let { labelProps, fieldProps } = useLabel(props);\n\n  let isVertical = props.orientation === 'vertical';\n\n  sliderIds.set(state, labelProps.id ?? fieldProps.id);\n  let currentPointer = useRef<number | null | undefined>(undefined);\n\n  let onDownTrack = (\n    e: React.UIEvent,\n    id: number,\n    clientX: number,\n    clientY: number\n  ) => {\n    const direction = isRTL() ? 'rtl' : undefined;\n    if (\n      !props.isDisabled &&\n      state.values.every((_, i) => !state.isThumbDragging(i))\n    ) {\n      let size = isVertical ? trackLayout.height : trackLayout.width;\n      // Find the closest thumb\n      const trackPosition = trackLayout[isVertical ? 'y' : 'x'];\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === 'rtl' || isVertical) {\n        percent = 1 - percent;\n      }\n      let value = state.getPercentValue(percent);\n      // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n      let closestThumb;\n      let split = state.values.findIndex((v) => value - v < 0);\n      if (split === 0) {\n        // If the index is zero then the closetThumb is the first one\n        closestThumb = split;\n      } else if (split === -1) {\n        // If no index is found they've clicked past all the thumbs\n        closestThumb = state.values.length - 1;\n      } else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split];\n        // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) {\n          closestThumb = split - 1;\n        } else {\n          closestThumb = split;\n        }\n      }\n      // Confirm that the found closest thumb is editable, not disabled, and move it\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n        state.setThumbDragging(closestThumb, true);\n        state.setThumbValue(closestThumb, value);\n        state.setThumbDragging(closestThumb, false);\n      }\n    }\n  };\n\n  return {\n    labelProps,\n    groupProps: {},\n    trackProps: {\n      onPress: (e: any) => {\n        const { locationX, locationY } = e.nativeEvent;\n        onDownTrack(e, undefined, locationX, locationY);\n      },\n    },\n    outputProps: {},\n  };\n}\n"]}