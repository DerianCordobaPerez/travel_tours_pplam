{"version":3,"sources":["useSlider.ts"],"names":["sliderIds","useRef","useLabel","isRTL","useSlider","props","state","trackLayout","labelProps","fieldProps","isVertical","orientation","set","id","currentPointer","undefined","onDownTrack","e","clientX","clientY","direction","isDisabled","values","every","_","i","isThumbDragging","size","height","width","trackPosition","clickPosition","offset","percent","value","getPercentValue","closestThumb","split","findIndex","v","length","lastLeft","firstRight","Math","abs","isThumbEditable","preventDefault","setFocusedThumb","current","setThumbDragging","setThumbValue","groupProps","trackProps","onPress","locationX","locationY","nativeEvent","outputProps"],"mappings":"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","sourcesContent":["import { sliderIds } from './utils';\nimport { AriaSliderProps } from '@react-types/slider';\nimport React, { useRef } from 'react';\nimport { SliderState } from '@react-stately/slider';\nimport { useLabel } from '@react-aria/label';\nimport { isRTL } from '@react-native-aria/utils';\n\ninterface SliderAria {\n  /** Props for the label element. */\n  labelProps: any;\n\n  /** Props for the root element of the slider component; groups slider inputs. */\n  groupProps: any;\n\n  /** Props for the track element. */\n  trackProps: any;\n\n  /** Props for the output element, displaying the value of the slider thumbs. */\n  outputProps: any;\n}\n\n/**\n * Provides the behavior and accessibility implementation for a slider component representing one or more values.\n *\n * @param props Props for the slider.\n * @param state State for the slider, as returned by `useSliderState`.\n * @param trackRef Ref for the \"track\" element.  The width of this element provides the \"length\"\n * of the track -- the span of one dimensional space that the slider thumb can be.  It also\n * accepts click and drag motions, so that the closest thumb will follow clicks and drags on\n * the track.\n */\nexport function useSlider(\n  props: AriaSliderProps,\n  state: SliderState,\n  trackLayout: any\n): SliderAria {\n  let { labelProps, fieldProps } = useLabel(props);\n\n  let isVertical = props.orientation === 'vertical';\n\n  sliderIds.set(state, labelProps.id ?? fieldProps.id);\n  let currentPointer = useRef<number | null | undefined>(undefined);\n\n  let onDownTrack = (\n    e: React.UIEvent,\n    id: number,\n    clientX: number,\n    clientY: number\n  ) => {\n    const direction = isRTL() ? 'rtl' : undefined;\n    if (\n      !props.isDisabled &&\n      state.values.every((_, i) => !state.isThumbDragging(i))\n    ) {\n      let size = isVertical ? trackLayout.height : trackLayout.width;\n      // Find the closest thumb\n      const trackPosition = trackLayout[isVertical ? 'y' : 'x'];\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === 'rtl' || isVertical) {\n        percent = 1 - percent;\n      }\n      let value = state.getPercentValue(percent);\n      // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n      let closestThumb;\n      let split = state.values.findIndex((v) => value - v < 0);\n      if (split === 0) {\n        // If the index is zero then the closetThumb is the first one\n        closestThumb = split;\n      } else if (split === -1) {\n        // If no index is found they've clicked past all the thumbs\n        closestThumb = state.values.length - 1;\n      } else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split];\n        // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) {\n          closestThumb = split - 1;\n        } else {\n          closestThumb = split;\n        }\n      }\n      // Confirm that the found closest thumb is editable, not disabled, and move it\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n        state.setThumbDragging(closestThumb, true);\n        state.setThumbValue(closestThumb, value);\n        state.setThumbDragging(closestThumb, false);\n      }\n    }\n  };\n\n  return {\n    labelProps,\n    groupProps: {},\n    trackProps: {\n      onPress: (e: any) => {\n        const { locationX, locationY } = e.nativeEvent;\n        onDownTrack(e, undefined, locationX, locationY);\n      },\n    },\n    outputProps: {},\n  };\n}\n"]}