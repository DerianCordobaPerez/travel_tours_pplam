{"version":3,"sources":["useOverlayPosition.ts"],"names":["measureOffset","ref","Promise","resolve","current","measureInWindow","x","y","width","height","top","left","useOverlayPosition","props","targetRef","overlayRef","placement","offset","crossOffset","isOpen","shouldFlip","shouldOverlapWithTrigger","position","setPosition","React","useState","arrowOffsetLeft","undefined","arrowOffsetTop","maxHeight","rendered","setRendered","updatePosition","overlayOffset","triggerOffset","all","requestAnimationFrame","windowHeight","windowWidth","Dimensions","get","positions","calculatePosition","translateRTL","targetNode","overlayNode","scrollNode","padding","boundaryElement","useEffect","useLayoutEffect","returnProps","overlayProps","style","arrowProps","replace","opts","childOffset","isContainerPositioned","overlaySize","margins","bottom","right","scrollSize","boundaryDimensions","containerOffsetWithBoundary","calculatePositionInternal","placementInput","flip","placementInfo","parsePlacement","size","crossAxis","crossSize","crossPlacement","computePosition","normalizedOffset","space","getAvailableSpace","flippedPlacementInfo","FLIPPED_DIRECTION","flippedPosition","flippedSpace","delta","getDelta","getMaxHeight","Math","min","arrowPosition","axis","containerDimensions","containerScroll","containerHeight","AXIS_SIZE","startEdgeOffset","endEdgeOffset","max","_containerOffsetWithBoundary","_margins","_padding","_isContainerPositioned","minViablePosition","maxViablePosition","floor","AXIS","CROSS_AXIS","PARSED_PLACEMENT_CACHE","input","split"],"mappings":"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","sourcesContent":["import type { PlacementAxis } from '@react-types/overlays';\nimport React, { RefObject } from 'react';\nimport type { Axis, SizeAxis } from '@react-types/overlays';\nimport {\n  //@ts-ignore\n  Dimensions,\n} from 'react-native';\nimport type { Placement, PositionProps } from '@react-types/overlays';\nimport { isRTL } from '@react-native-aria/utils';\n\nconst measureOffset = (ref: RefObject<any>) =>\n  new Promise<IMeasureResult>((resolve) => {\n    if (ref.current) {\n      ref.current.measureInWindow(\n        (x: number, y: number, width: number, height: number) => {\n          resolve({ top: y, left: x, width, height });\n        }\n      );\n    }\n  });\n\ninterface ParsedPlacement {\n  placement: PlacementAxis;\n  crossPlacement: PlacementAxis;\n  axis: Axis;\n  crossAxis: Axis;\n  size: SizeAxis;\n  crossSize: SizeAxis;\n}\ninterface AriaPositionProps extends PositionProps {\n  /**\n   * Element that that serves as the positioning boundary.\n   * @default document.body\n   */\n  boundaryElement?: any;\n  /**\n   * The ref for the element which the overlay positions itself with respect to.\n   */\n  targetRef: RefObject<any>;\n  /**\n   * The ref for the overlay element.\n   */\n  overlayRef: RefObject<any>;\n  /**\n   * A ref for the scrollable region within the overlay.\n   * @default overlayRef\n   */\n  scrollRef?: RefObject<any>;\n  /**\n   * Whether the overlay should update its position automatically.\n   * @default true\n   */\n  shouldUpdatePosition?: boolean;\n  /** Handler that is called when the overlay should close. */\n  onClose?: () => void;\n  /** Determines whether the overlay should overlap with the trigger */\n  shouldOverlapWithTrigger?: boolean;\n}\n\ntype IMeasureResult = {\n  top: number;\n  left: number;\n  height: number;\n  width: number;\n};\n\nexport function useOverlayPosition(props: AriaPositionProps) {\n  let {\n    targetRef,\n    overlayRef,\n    placement = 'bottom' as Placement,\n    offset = 0,\n    crossOffset = 0,\n    isOpen = true,\n    shouldFlip = true,\n    shouldOverlapWithTrigger = false,\n  } = props;\n\n  let [position, setPosition] = React.useState<PositionResult>({\n    position: {},\n    arrowOffsetLeft: undefined,\n    arrowOffsetTop: undefined,\n    maxHeight: undefined,\n    placement: undefined,\n  });\n\n  // Layout measurement happens asynchronously in RN. This causes initial flickr. Using opacity and setting it to 1 post calculation prevents that.\n  let [rendered, setRendered] = React.useState(false);\n\n  let updatePosition = async () => {\n    const [overlayOffset, triggerOffset] = await Promise.all([\n      measureOffset(overlayRef),\n      measureOffset(targetRef),\n    ]);\n\n    // Sometimes measure returns height/width 0. Best solution would be to use onLayout callback, but that might diverege from React Aria's useOverlayPosition API. Decide later, this works for now\n    if (\n      !overlayOffset.width ||\n      !overlayOffset.height ||\n      !triggerOffset.width ||\n      !triggerOffset.height\n    ) {\n      requestAnimationFrame(updatePosition);\n      return;\n    }\n\n    const { height: windowHeight, width: windowWidth } = Dimensions.get(\n      'window'\n    );\n\n    const positions = calculatePosition({\n      placement: translateRTL(placement),\n      targetNode: triggerOffset,\n      overlayNode: overlayOffset,\n      scrollNode: overlayOffset,\n      padding: 0,\n      shouldFlip,\n      boundaryElement: {\n        top: 0,\n        left: 0,\n        width: windowWidth,\n        height: windowHeight,\n      },\n      offset,\n      crossOffset,\n      shouldOverlapWithTrigger,\n    });\n    setPosition(positions);\n    setRendered(true);\n  };\n  React.useEffect(() => {\n    return () => {\n      setRendered(false);\n    };\n  }, []);\n\n  React.useLayoutEffect(() => {\n    updatePosition();\n  }, [placement, isOpen, offset, shouldFlip, crossOffset, shouldOverlapWithTrigger]);\n\n  const returnProps = {\n    rendered,\n    overlayProps: {\n      style: {\n        ...position.position,\n      },\n    },\n    placement: position.placement,\n    arrowProps: {\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop,\n      },\n    },\n    updatePosition,\n  };\n\n  if (position.maxHeight !== undefined) {\n    //@ts-ignore\n    returnProps.overlayProps.style.maxHeight = position.maxHeight;\n  }\n\n  return returnProps;\n}\n\nfunction translateRTL(position: any) {\n  if (isRTL()) {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n  return position.replace('start', 'left').replace('end', 'right');\n}\n\ninterface Position {\n  top?: number;\n  left?: number;\n  bottom?: number;\n  right?: number;\n}\n\ninterface Dimensions {\n  width: number;\n  height: number;\n  top: number;\n  left: number;\n  scroll: Position;\n}\n\ninterface Offset {\n  top: number;\n  left: number;\n  width: number;\n  height: number;\n}\n\nexport interface PositionResult {\n  position?: Position;\n  arrowOffsetLeft?: number;\n  arrowOffsetTop?: number;\n  maxHeight?: number;\n  placement: PlacementAxis | undefined;\n}\n\nconst calculatePosition = (opts: any): PositionResult => {\n  let {\n    placement,\n    targetNode,\n    overlayNode,\n    scrollNode,\n    padding,\n    shouldFlip,\n    boundaryElement,\n    offset,\n    crossOffset,\n    shouldOverlapWithTrigger,\n  } = opts;\n\n  let childOffset: Offset = targetNode;\n  let isContainerPositioned = false;\n  let overlaySize: Offset = overlayNode;\n  let margins = { top: 0, bottom: 0, left: 0, right: 0 };\n  let scrollSize = scrollNode;\n  let boundaryDimensions = boundaryElement;\n\n  let containerOffsetWithBoundary: Offset = overlayNode;\n\n  return calculatePositionInternal(\n    placement,\n    childOffset,\n    overlaySize,\n    scrollSize,\n    margins,\n    padding,\n    shouldFlip,\n    boundaryDimensions,\n    containerOffsetWithBoundary,\n    offset,\n    crossOffset,\n    isContainerPositioned,\n    shouldOverlapWithTrigger\n  );\n};\n\nfunction calculatePositionInternal(\n  placementInput: Placement,\n  childOffset: any,\n  overlaySize: Offset,\n  scrollSize: Offset,\n  margins: Position,\n  padding: number,\n  flip: boolean,\n  boundaryDimensions: Dimensions,\n  containerOffsetWithBoundary: Offset,\n  offset: number,\n  crossOffset: number,\n  isContainerPositioned: boolean,\n  shouldOverlapWithTrigger: boolean\n): PositionResult {\n  let placementInfo = parsePlacement(placementInput);\n  let { size, crossAxis, crossSize, placement, crossPlacement } = placementInfo;\n  let position = computePosition(\n    childOffset,\n    boundaryDimensions,\n    overlaySize,\n    placementInfo,\n    offset,\n    crossOffset,\n    containerOffsetWithBoundary,\n    isContainerPositioned\n  );\n  let normalizedOffset = offset;\n  let space = getAvailableSpace(\n    boundaryDimensions,\n    containerOffsetWithBoundary,\n    childOffset,\n    margins,\n    padding + offset,\n    placementInfo\n  );\n\n  if (flip && scrollSize[size] > space) {\n    let flippedPlacementInfo = parsePlacement(\n      `${FLIPPED_DIRECTION[placement]} ${crossPlacement}` as Placement\n    );\n    let flippedPosition = computePosition(\n      childOffset,\n      boundaryDimensions,\n      overlaySize,\n      flippedPlacementInfo,\n      offset,\n      crossOffset,\n      containerOffsetWithBoundary,\n      isContainerPositioned\n    );\n    let flippedSpace = getAvailableSpace(\n      boundaryDimensions,\n      containerOffsetWithBoundary,\n      childOffset,\n      margins,\n      padding + offset,\n      flippedPlacementInfo\n    );\n\n    // If the available space for the flipped position is greater than the original available space, flip.\n    if (flippedSpace > space) {\n      placementInfo = flippedPlacementInfo;\n      position = flippedPosition;\n      normalizedOffset = offset;\n    }\n  }\n\n  let delta = getDelta(\n    crossAxis,\n    position[crossAxis],\n    overlaySize[crossSize],\n    boundaryDimensions,\n    padding\n  );\n  position[crossAxis] += delta;\n\n  let maxHeight = getMaxHeight(\n    position,\n    boundaryDimensions,\n    containerOffsetWithBoundary,\n    childOffset,\n    margins,\n    padding\n  );\n\n  overlaySize.height = Math.min(overlaySize.height, maxHeight);\n\n  position = computePosition(\n    childOffset,\n    boundaryDimensions,\n    overlaySize,\n    placementInfo,\n    normalizedOffset,\n    crossOffset,\n    containerOffsetWithBoundary,\n    isContainerPositioned\n  );\n\n  delta = getDelta(\n    crossAxis,\n    position[crossAxis],\n    overlaySize[crossSize],\n    boundaryDimensions,\n    padding\n  );\n  position[crossAxis] += delta;\n\n  let arrowPosition: Position = {};\n  arrowPosition[crossAxis] =\n    childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;\n\n  if (shouldOverlapWithTrigger) {\n    position[FLIPPED_DIRECTION[placementInfo.placement]] =\n      position[FLIPPED_DIRECTION[placementInfo.placement]] - childOffset[size];\n  }\n\n  return {\n    position,\n    maxHeight,\n    arrowOffsetLeft: arrowPosition.left,\n    arrowOffsetTop: arrowPosition.top,\n    placement: placementInfo.placement,\n  };\n}\n\nfunction getDelta(\n  axis: Axis,\n  offset: number,\n  size: number,\n  containerDimensions: Dimensions,\n  padding: number\n) {\n  //@ts-ignore\n  let containerScroll = containerDimensions[axis];\n  //@ts-ignore\n  let containerHeight = containerDimensions[AXIS_SIZE[axis]];\n\n  let startEdgeOffset = offset - padding - containerScroll;\n  let endEdgeOffset = offset + padding - containerScroll + size;\n\n  if (startEdgeOffset < 0) {\n    return -startEdgeOffset;\n  } else if (endEdgeOffset > containerHeight) {\n    return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);\n  } else {\n    return 0;\n  }\n}\n\nfunction getMaxHeight(\n  position: Position,\n  boundaryDimensions: Dimensions,\n  _containerOffsetWithBoundary: Offset,\n  childOffset: Offset,\n  _margins: Position,\n  _padding: number\n) {\n  return position.top != null\n    ? // We want the distance between the top of the overlay to the bottom of the boundary\n      Math.max(\n        0,\n        boundaryDimensions.height - // this is the bottom of the boundary\n          position.top // this is the top of the overlay\n      )\n    : // We want the distance between the top of the trigger to the top of the boundary\n      Math.max(\n        0,\n        childOffset.top - // this is the top of the trigger\n          0 // this is the top of the boundary\n      );\n}\n\nfunction computePosition(\n  childOffset: any,\n  boundaryDimensions: Dimensions,\n  overlaySize: Offset,\n  placementInfo: ParsedPlacement,\n  offset: number,\n  crossOffset: number,\n  _containerOffsetWithBoundary: Offset,\n  _isContainerPositioned: boolean\n) {\n  let {\n    placement,\n    crossPlacement,\n    axis,\n    crossAxis,\n    size,\n    crossSize,\n  } = placementInfo;\n  let position: any = {};\n  //@ts-ignore\n  position[crossAxis] = childOffset[crossAxis];\n\n  if (crossPlacement === 'center') {\n    position[crossAxis] +=\n      (childOffset[crossSize] - overlaySize[crossSize]) / 2;\n  } else if (crossPlacement !== crossAxis) {\n    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];\n  }\n\n  position[crossAxis] += crossOffset;\n\n  // this is button center position - the overlay size + half of the button to align bottom of overlay with button center\n  let minViablePosition =\n    childOffset[crossAxis] +\n    childOffset[crossSize] / 2 -\n    overlaySize[crossSize];\n  // this is button position of center, aligns top of overlay with button center\n  let maxViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2;\n\n  // clamp it into the range of the min/max positions\n  position[crossAxis] = Math.min(\n    Math.max(minViablePosition, position[crossAxis]),\n    maxViablePosition\n  );\n\n  // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.\n  if (placement === axis) {\n    // If the container is positioned (non-static), then we use the container's actual\n    // height, as `bottom` will be relative to this height.  But if the container is static,\n    // then it can only be the `document.body`, and `bottom` will be relative to _its_\n    // container, which should be as large as boundaryDimensions.\n    const containerHeight = boundaryDimensions[size];\n    position[FLIPPED_DIRECTION[axis]] = Math.floor(\n      containerHeight - childOffset[axis] + offset\n    );\n  } else {\n    position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);\n  }\n\n  return position;\n}\n\nfunction getAvailableSpace(\n  boundaryDimensions: Dimensions,\n  _containerOffsetWithBoundary: Offset,\n  childOffset: any,\n  _margins: Position,\n  padding: number,\n  placementInfo: ParsedPlacement\n) {\n  let { placement, axis, size } = placementInfo;\n  if (placement === axis) {\n    return Math.max(0, childOffset[axis] - padding);\n  }\n\n  return Math.max(\n    0,\n    boundaryDimensions[size] - childOffset[axis] - childOffset[size] - padding\n  );\n}\n\nconst AXIS: any = {\n  top: 'top',\n  bottom: 'top',\n  left: 'left',\n  right: 'left',\n};\n\nconst FLIPPED_DIRECTION: any = {\n  top: 'bottom',\n  bottom: 'top',\n  left: 'right',\n  right: 'left',\n};\n\nconst CROSS_AXIS: any = {\n  top: 'left',\n  left: 'top',\n};\n\nconst AXIS_SIZE: any = {\n  top: 'height',\n  left: 'width',\n};\n\ninterface Position {\n  top?: number;\n  left?: number;\n  bottom?: number;\n  right?: number;\n}\n\ninterface Dimensions {\n  width: number;\n  height: number;\n  top: number;\n  left: number;\n  scroll: Position;\n}\n\ninterface Offset {\n  top: number;\n  left: number;\n  width: number;\n  height: number;\n}\n\nconst PARSED_PLACEMENT_CACHE: any = {};\n\nfunction parsePlacement(input: Placement): ParsedPlacement {\n  if (PARSED_PLACEMENT_CACHE[input]) {\n    return PARSED_PLACEMENT_CACHE[input];\n  }\n\n  let [placement, crossPlacement] = input.split(' ');\n  let axis: Axis = AXIS[placement] || 'right';\n  let crossAxis: Axis = CROSS_AXIS[axis];\n\n  if (!AXIS[crossPlacement]) {\n    crossPlacement = 'center';\n  }\n\n  let size = AXIS_SIZE[axis];\n  let crossSize = AXIS_SIZE[crossAxis];\n  PARSED_PLACEMENT_CACHE[input] = {\n    placement,\n    crossPlacement,\n    axis,\n    crossAxis,\n    size,\n    crossSize,\n  };\n  return PARSED_PLACEMENT_CACHE[input];\n}\n"]}